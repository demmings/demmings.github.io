<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Sql.js - gsSQL</title>
    
    <meta name="description" content="Query Google Sheets using standard SQL SELECT syntax." />
    
        <meta name="keywords" content="Google, Sheets, Query, SQL, SELECT" />
        <meta name="keyword" content="Google, Sheets, Query, SQL, SELECT" />
    
    
    
    <meta property="og:title" content="gsSQL Sheets Custom Function"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://demmings.github.io/img/logo.png"/>
    <meta property="og:site_name" content="gsSQL"/>
    <meta property="og:url" content="https://demmings.github.io/"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://demmings.github.io" target="_blank" class="menu-item" id="website_link" >Project Website</a></h2><h2><a href="https://github.com/demmings/gsSQL" target="_blank" class="menu-item" id="website_link" >Github Website</a></h2><h3>Classes</h3><ul><li><a href="BindData.html">BindData</a><ul class='methods'><li data-type='method'><a href="BindData.html#add">add</a></li><li data-type='method'><a href="BindData.html#addList">addList</a></li><li data-type='method'><a href="BindData.html#clear">clear</a></li><li data-type='method'><a href="BindData.html#get">get</a></li><li data-type='method'><a href="BindData.html#getBindDataList">getBindDataList</a></li></ul></li><li><a href="CalculatedField.html">CalculatedField</a><ul class='methods'><li data-type='method'><a href="CalculatedField.html#createAssignmentStatments">createAssignmentStatments</a></li><li data-type='method'><a href="CalculatedField.html#evaluateCalculatedField">evaluateCalculatedField</a></li><li data-type='method'><a href="CalculatedField.html#getData">getData</a></li><li data-type='method'><a href="CalculatedField.html#sqlServerCalcFields">sqlServerCalcFields</a></li><li data-type='method'><a href="CalculatedField.html#sqlServerFunctions">sqlServerFunctions</a></li></ul></li><li><a href="CondLexer.html">CondLexer</a><ul class='methods'><li data-type='method'><a href="CondLexer.html#isFinishedWord">isFinishedWord</a></li><li data-type='method'><a href="CondLexer.html#isStartOrEndOfString">isStartOrEndOfString</a></li></ul></li><li><a href="CondParser.html">CondParser</a><ul class='methods'><li data-type='method'><a href="CondParser.html#parseBaseExpression">parseBaseExpression</a></li><li data-type='method'><a href="CondParser.html#parseGroupExpression">parseGroupExpression</a></li><li data-type='method'><a href="CondParser.html#parseSelectExistsSubQuery">parseSelectExistsSubQuery</a></li><li data-type='method'><a href="CondParser.html#parseSelectIn">parseSelectIn</a></li><li data-type='method'><a href="CondParser.html#parseWordExpression">parseWordExpression</a></li></ul></li><li><a href="ConglomerateRecord.html">ConglomerateRecord</a><ul class='methods'><li data-type='method'><a href="ConglomerateRecord.html#squish">squish</a></li><li data-type='method'><a href="ConglomerateRecord.html#.aggregateColumn">aggregateColumn</a></li><li data-type='method'><a href="ConglomerateRecord.html#.maxCase">maxCase</a></li><li data-type='method'><a href="ConglomerateRecord.html#.minCase">minCase</a></li></ul></li><li><a href="CorrelatedSubQuery.html">CorrelatedSubQuery</a><ul class='methods'><li data-type='method'><a href="CorrelatedSubQuery.html#replaceOuterFieldValueInCorrelatedWhere">replaceOuterFieldValueInCorrelatedWhere</a></li><li data-type='method'><a href="CorrelatedSubQuery.html#select">select</a></li><li data-type='method'><a href="CorrelatedSubQuery.html#traverseWhere">traverseWhere</a></li></ul></li><li><a href="DerivedTable.html">DerivedTable</a><ul class='methods'><li data-type='method'><a href="DerivedTable.html#createTable">createTable</a></li><li data-type='method'><a href="DerivedTable.html#getTableData">getTableData</a></li><li data-type='method'><a href="DerivedTable.html#isDerivedTable">isDerivedTable</a></li><li data-type='method'><a href="DerivedTable.html#setIsOuterJoin">setIsOuterJoin</a></li><li data-type='method'><a href="DerivedTable.html#setLeftField">setLeftField</a></li><li data-type='method'><a href="DerivedTable.html#setLeftRecords">setLeftRecords</a></li><li data-type='method'><a href="DerivedTable.html#setRightField">setRightField</a></li><li data-type='method'><a href="DerivedTable.html#.getCombinedColumnTitles">getCombinedColumnTitles</a></li></ul></li><li><a href="JoinTables.html">JoinTables</a><ul class='methods'><li data-type='method'><a href="JoinTables.html#getJoinedTableInfo">getJoinedTableInfo</a></li><li data-type='method'><a href="JoinTables.html#getRecordIDs">getRecordIDs</a></li><li data-type='method'><a href="JoinTables.html#isDerivedTable">isDerivedTable</a></li><li data-type='method'><a href="JoinTables.html#joinCondition">joinCondition</a></li><li data-type='method'><a href="JoinTables.html#joinNextTable">joinNextTable</a></li><li data-type='method'><a href="JoinTables.html#load">load</a></li><li data-type='method'><a href="JoinTables.html#resolveCondition">resolveCondition</a></li><li data-type='method'><a href="JoinTables.html#.andJoinIds">andJoinIds</a></li><li data-type='method'><a href="JoinTables.html#.getLeftRightFieldInfo">getLeftRightFieldInfo</a></li><li data-type='method'><a href="JoinTables.html#.getMatchedRecordIds">getMatchedRecordIds</a></li><li data-type='method'><a href="JoinTables.html#.joinTables">joinTables</a></li><li data-type='method'><a href="JoinTables.html#.leftRightJoin">leftRightJoin</a></li><li data-type='method'><a href="JoinTables.html#.orJoinIds">orJoinIds</a></li></ul></li><li><a href="PropertyData.html">PropertyData</a><ul class='methods'><li data-type='method'><a href="PropertyData.html#.getData">getData</a></li><li data-type='method'><a href="PropertyData.html#.isExpired">isExpired</a></li></ul></li><li><a href="Schema.html">Schema</a><ul class='methods'><li data-type='method'><a href="Schema.html#getAllExtendedNotationFieldNames">getAllExtendedNotationFieldNames</a></li><li data-type='method'><a href="Schema.html#getAllFieldNames">getAllFieldNames</a></li><li data-type='method'><a href="Schema.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="Schema.html#getColumnNameVariants">getColumnNameVariants</a></li><li data-type='method'><a href="Schema.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="Schema.html#getFieldColumns">getFieldColumns</a></li><li data-type='method'><a href="Schema.html#load">load</a></li><li data-type='method'><a href="Schema.html#setFieldVariantsColumNumber">setFieldVariantsColumNumber</a></li><li data-type='method'><a href="Schema.html#setTable">setTable</a></li><li data-type='method'><a href="Schema.html#setTableAlias">setTableAlias</a></li><li data-type='method'><a href="Schema.html#setTableData">setTableData</a></li><li data-type='method'><a href="Schema.html#setTableName">setTableName</a></li></ul></li><li><a href="ScriptSettings.html">ScriptSettings</a><ul class='methods'><li data-type='method'><a href="ScriptSettings.html#expire">expire</a></li><li data-type='method'><a href="ScriptSettings.html#get">get</a></li><li data-type='method'><a href="ScriptSettings.html#put">put</a></li><li data-type='method'><a href="ScriptSettings.html#putAll">putAll</a></li></ul></li><li><a href="SelectKeywordAnalysis.html">SelectKeywordAnalysis</a><ul class='methods'><li data-type='method'><a href="SelectKeywordAnalysis.html#.getNameAndAlias">getNameAndAlias</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.lastIndexOfOutsideLiteral">lastIndexOfOutsideLiteral</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.parseForCorrelatedSubQuery">parseForCorrelatedSubQuery</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.protect_split">protect_split</a></li></ul></li><li><a href="SelectTables.html">SelectTables</a><ul class='methods'><li data-type='method'><a href="SelectTables.html#createGroupByKey">createGroupByKey</a></li><li data-type='method'><a href="SelectTables.html#getColumnTitles">getColumnTitles</a></li><li data-type='method'><a href="SelectTables.html#getRecordIDs">getRecordIDs</a></li><li data-type='method'><a href="SelectTables.html#getViewData">getViewData</a></li><li data-type='method'><a href="SelectTables.html#groupBy">groupBy</a></li><li data-type='method'><a href="SelectTables.html#groupByFields">groupByFields</a></li><li data-type='method'><a href="SelectTables.html#having">having</a></li><li data-type='method'><a href="SelectTables.html#join">join</a></li><li data-type='method'><a href="SelectTables.html#orderBy">orderBy</a></li><li data-type='method'><a href="SelectTables.html#removeTempColumns">removeTempColumns</a></li><li data-type='method'><a href="SelectTables.html#resolveBindData">resolveBindData</a></li><li data-type='method'><a href="SelectTables.html#resolveCondition">resolveCondition</a></li><li data-type='method'><a href="SelectTables.html#resolveFieldCondition">resolveFieldCondition</a></li><li data-type='method'><a href="SelectTables.html#resolveSubQuery">resolveSubQuery</a></li><li data-type='method'><a href="SelectTables.html#updateSelectedFields">updateSelectedFields</a></li><li data-type='method'><a href="SelectTables.html#whereCondition">whereCondition</a></li><li data-type='method'><a href="SelectTables.html#.dateToMs">dateToMs</a></li><li data-type='method'><a href="SelectTables.html#.existsCondition">existsCondition</a></li><li data-type='method'><a href="SelectTables.html#.extractStringConstant">extractStringConstant</a></li><li data-type='method'><a href="SelectTables.html#.getConditionValue">getConditionValue</a></li><li data-type='method'><a href="SelectTables.html#.getSubQueryTableSet">getSubQueryTableSet</a></li><li data-type='method'><a href="SelectTables.html#.inCondition">inCondition</a></li><li data-type='method'><a href="SelectTables.html#.isCondition">isCondition</a></li><li data-type='method'><a href="SelectTables.html#.isConditionTrue">isConditionTrue</a></li><li data-type='method'><a href="SelectTables.html#.isStringConstant">isStringConstant</a></li><li data-type='method'><a href="SelectTables.html#.likeCondition">likeCondition</a></li><li data-type='method'><a href="SelectTables.html#.parseForFunctions">parseForFunctions</a></li><li data-type='method'><a href="SelectTables.html#.parseForParams">parseForParams</a></li><li data-type='method'><a href="SelectTables.html#.sortByColumnASC">sortByColumnASC</a></li><li data-type='method'><a href="SelectTables.html#.sortByColumnDESC">sortByColumnDESC</a></li><li data-type='method'><a href="SelectTables.html#.toUpperCaseExceptQuoted">toUpperCaseExceptQuoted</a></li></ul></li><li><a href="Sql.html">Sql</a><ul class='methods'><li data-type='method'><a href="Sql.html#addBindNamedRangeParameter">addBindNamedRangeParameter</a></li><li data-type='method'><a href="Sql.html#addBindParameter">addBindParameter</a></li><li data-type='method'><a href="Sql.html#addTableData">addTableData</a></li><li data-type='method'><a href="Sql.html#areColumnTitlesOutput">areColumnTitlesOutput</a></li><li data-type='method'><a href="Sql.html#clearBindParameters">clearBindParameters</a></li><li data-type='method'><a href="Sql.html#copyTableData">copyTableData</a></li><li data-type='method'><a href="Sql.html#enableColumnTitle">enableColumnTitle</a></li><li data-type='method'><a href="Sql.html#execute">execute</a></li><li data-type='method'><a href="Sql.html#getBindData">getBindData</a></li><li data-type='method'><a href="Sql.html#getTables">getTables</a></li><li data-type='method'><a href="Sql.html#getUniquePivotData">getUniquePivotData</a></li><li data-type='method'><a href="Sql.html#pivotField">pivotField</a></li><li data-type='method'><a href="Sql.html#replaceColumnTableNameWith">replaceColumnTableNameWith</a></li><li data-type='method'><a href="Sql.html#select">select</a></li><li data-type='method'><a href="Sql.html#selectFromSubQuery">selectFromSubQuery</a></li><li data-type='method'><a href="Sql.html#selectJoinSubQuery">selectJoinSubQuery</a></li><li data-type='method'><a href="Sql.html#setBindValues">setBindValues</a></li><li data-type='method'><a href="Sql.html#setTables">setTables</a></li><li data-type='method'><a href="Sql.html#unionSets">unionSets</a></li><li data-type='method'><a href="Sql.html#.addCalculatedPivotFieldsToAst">addCalculatedPivotFieldsToAst</a></li><li data-type='method'><a href="Sql.html#.appendUniqueRows">appendUniqueRows</a></li><li data-type='method'><a href="Sql.html#.distinctField">distinctField</a></li><li data-type='method'><a href="Sql.html#.exceptRows">exceptRows</a></li><li data-type='method'><a href="Sql.html#.extractAstTables">extractAstTables</a></li><li data-type='method'><a href="Sql.html#.getReferencedTableNames">getReferencedTableNames</a></li><li data-type='method'><a href="Sql.html#.getReferencedTableNamesFromAst">getReferencedTableNamesFromAst</a></li><li data-type='method'><a href="Sql.html#.getTableAlias">getTableAlias</a></li><li data-type='method'><a href="Sql.html#.getTableAliasFromJoin">getTableAliasFromJoin</a></li><li data-type='method'><a href="Sql.html#.getTableAliasUnion">getTableAliasUnion</a></li><li data-type='method'><a href="Sql.html#.getTableAliasWhereIn">getTableAliasWhereIn</a></li><li data-type='method'><a href="Sql.html#.getTableAliasWhereTerms">getTableAliasWhereTerms</a></li><li data-type='method'><a href="Sql.html#.getTableNamesCorrelatedSelect">getTableNamesCorrelatedSelect</a></li><li data-type='method'><a href="Sql.html#.getTableNamesFrom">getTableNamesFrom</a></li><li data-type='method'><a href="Sql.html#.getTableNamesJoin">getTableNamesJoin</a></li><li data-type='method'><a href="Sql.html#.getTableNamesUnion">getTableNamesUnion</a></li><li data-type='method'><a href="Sql.html#.getTableNamesWhereCondition">getTableNamesWhereCondition</a></li><li data-type='method'><a href="Sql.html#.getTableNamesWhereIn">getTableNamesWhereIn</a></li><li data-type='method'><a href="Sql.html#.getTableNamesWhereTerms">getTableNamesWhereTerms</a></li><li data-type='method'><a href="Sql.html#.intersectRows">intersectRows</a></li><li data-type='method'><a href="Sql.html#.isIterable">isIterable</a></li><li data-type='method'><a href="Sql.html#.loadSchema">loadSchema</a></li><li data-type='method'><a href="Sql.html#.locateAstTableAlias">locateAstTableAlias</a></li><li data-type='method'><a href="Sql.html#.setTableAlias">setTableAlias</a></li></ul></li><li><a href="SqlParse.html">SqlParse</a><ul class='methods'><li data-type='method'><a href="SqlParse.html#.analyzeParts">analyzeParts</a></li><li data-type='method'><a href="SqlParse.html#.generateSqlSeparatorWords">generateSqlSeparatorWords</a></li><li data-type='method'><a href="SqlParse.html#.generateUsedKeywordList">generateUsedKeywordList</a></li><li data-type='method'><a href="SqlParse.html#.getPositionsOfSqlParts">getPositionsOfSqlParts</a></li><li data-type='method'><a href="SqlParse.html#.hideInnerSql">hideInnerSql</a></li><li data-type='method'><a href="SqlParse.html#.makeSqlPartsSplitterRegEx">makeSqlPartsSplitterRegEx</a></li><li data-type='method'><a href="SqlParse.html#.protect">protect</a></li><li data-type='method'><a href="SqlParse.html#.removeDuplicateEntries">removeDuplicateEntries</a></li><li data-type='method'><a href="SqlParse.html#.reorganizeJoins">reorganizeJoins</a></li><li data-type='method'><a href="SqlParse.html#.reorganizeSpecificJoin">reorganizeSpecificJoin</a></li><li data-type='method'><a href="SqlParse.html#.reorganizeUnions">reorganizeUnions</a></li><li data-type='method'><a href="SqlParse.html#.resolveSqlCondition">resolveSqlCondition</a></li><li data-type='method'><a href="SqlParse.html#.sql2ast">sql2ast</a></li><li data-type='method'><a href="SqlParse.html#.sqlCondition2JsCondition">sqlCondition2JsCondition</a></li><li data-type='method'><a href="SqlParse.html#.sqlStatementSplitter">sqlStatementSplitter</a></li><li data-type='method'><a href="SqlParse.html#.unprotect">unprotect</a></li></ul></li><li><a href="SqlServerFunctions.html">SqlServerFunctions</a><ul class='methods'><li data-type='method'><a href="SqlServerFunctions.html#caseEnd">caseEnd</a></li><li data-type='method'><a href="SqlServerFunctions.html#caseStart">caseStart</a></li><li data-type='method'><a href="SqlServerFunctions.html#caseWhen">caseWhen</a></li><li data-type='method'><a href="SqlServerFunctions.html#convertToJs">convertToJs</a></li><li data-type='method'><a href="SqlServerFunctions.html#parseFunctionArgs">parseFunctionArgs</a></li><li data-type='method'><a href="SqlServerFunctions.html#.charIndex">charIndex</a></li><li data-type='method'><a href="SqlServerFunctions.html#.coalesce">coalesce</a></li><li data-type='method'><a href="SqlServerFunctions.html#.concat">concat</a></li><li data-type='method'><a href="SqlServerFunctions.html#.concat_ws">concat_ws</a></li><li data-type='method'><a href="SqlServerFunctions.html#.convert">convert</a></li></ul></li><li><a href="Table.html">Table</a><ul class='methods'><li data-type='method'><a href="Table.html#addColumnLetters">addColumnLetters</a></li><li data-type='method'><a href="Table.html#addIndex">addIndex</a></li><li data-type='method'><a href="Table.html#concat">concat</a></li><li data-type='method'><a href="Table.html#getAllExtendedNotationFieldNames">getAllExtendedNotationFieldNames</a></li><li data-type='method'><a href="Table.html#getAllFieldNames">getAllFieldNames</a></li><li data-type='method'><a href="Table.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="Table.html#getColumnCount">getColumnCount</a></li><li data-type='method'><a href="Table.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="Table.html#getFieldColumns">getFieldColumns</a></li><li data-type='method'><a href="Table.html#getRecords">getRecords</a></li><li data-type='method'><a href="Table.html#loadArrayData">loadArrayData</a></li><li data-type='method'><a href="Table.html#loadNamedRangeData">loadNamedRangeData</a></li><li data-type='method'><a href="Table.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="Table.html#numberToSheetColumnLetter">numberToSheetColumnLetter</a></li><li data-type='method'><a href="Table.html#search">search</a></li><li data-type='method'><a href="Table.html#setHasColumnTitle">setHasColumnTitle</a></li><li data-type='method'><a href="Table.html#setTableAlias">setTableAlias</a></li></ul></li><li><a href="TableData.html">TableData</a><ul class='methods'><li data-type='method'><a href="TableData.html#.cacheGetArray">cacheGetArray</a></li><li data-type='method'><a href="TableData.html#.cachePutArray">cachePutArray</a></li><li data-type='method'><a href="TableData.html#.cacheStatusName">cacheStatusName</a></li><li data-type='method'><a href="TableData.html#.fixJSONdates">fixJSONdates</a></li><li data-type='method'><a href="TableData.html#.forceLongCacheExpiryCheck">forceLongCacheExpiryCheck</a></li><li data-type='method'><a href="TableData.html#.getValueCached">getValueCached</a></li><li data-type='method'><a href="TableData.html#.getValuesCached">getValuesCached</a></li><li data-type='method'><a href="TableData.html#.isRangeLoading">isRangeLoading</a></li><li data-type='method'><a href="TableData.html#.isTimeToRunLongCacheExpiry">isTimeToRunLongCacheExpiry</a></li><li data-type='method'><a href="TableData.html#.loadTableData">loadTableData</a></li><li data-type='method'><a href="TableData.html#.loadValuesFromRangeOrSheet">loadValuesFromRangeOrSheet</a></li><li data-type='method'><a href="TableData.html#.lockLoadAndCache">lockLoadAndCache</a></li><li data-type='method'><a href="TableData.html#.setLongCacheExpiry">setLongCacheExpiry</a></li><li data-type='method'><a href="TableData.html#.setValueCached">setValueCached</a></li><li data-type='method'><a href="TableData.html#.setValuesCached">setValuesCached</a></li><li data-type='method'><a href="TableData.html#.verifyCachedData">verifyCachedData</a></li><li data-type='method'><a href="TableData.html#.waitForRangeToLoad">waitForRangeToLoad</a></li></ul></li><li><a href="TableField.html">TableField</a><ul class='methods'><li data-type='method'><a href="TableField.html#addAlias">addAlias</a></li><li data-type='method'><a href="TableField.html#getData">getData</a></li><li data-type='method'><a href="TableField.html#setAggregateFunction">setAggregateFunction</a></li><li data-type='method'><a href="TableField.html#setCalculatedFormula">setCalculatedFormula</a></li><li data-type='method'><a href="TableField.html#setColumnName">setColumnName</a></li><li data-type='method'><a href="TableField.html#setColumnTitle">setColumnTitle</a></li><li data-type='method'><a href="TableField.html#setDistinctSetting">setDistinctSetting</a></li><li data-type='method'><a href="TableField.html#setIsPrimaryTable">setIsPrimaryTable</a></li><li data-type='method'><a href="TableField.html#setIsTempField">setIsTempField</a></li><li data-type='method'><a href="TableField.html#setOriginalTable">setOriginalTable</a></li><li data-type='method'><a href="TableField.html#setOriginalTableColumn">setOriginalTableColumn</a></li><li data-type='method'><a href="TableField.html#setSelectColumn">setSelectColumn</a></li><li data-type='method'><a href="TableField.html#setSubQueryAst">setSubQueryAst</a></li><li data-type='method'><a href="TableField.html#setTableInfo">setTableInfo</a></li><li data-type='method'><a href="TableField.html#.getAllExtendedAliasNames">getAllExtendedAliasNames</a></li></ul></li><li><a href="TableFields.html">TableFields</a><ul class='methods'><li data-type='method'><a href="TableFields.html#addReferencedColumnstoSelectFieldList">addReferencedColumnstoSelectFieldList</a></li><li data-type='method'><a href="TableFields.html#addTempMissingSelectedField">addTempMissingSelectedField</a></li><li data-type='method'><a href="TableFields.html#findTableField">findTableField</a></li><li data-type='method'><a href="TableFields.html#getColumnNames">getColumnNames</a></li><li data-type='method'><a href="TableFields.html#getColumnTitles">getColumnTitles</a></li><li data-type='method'><a href="TableFields.html#getConglomerateFieldCount">getConglomerateFieldCount</a></li><li data-type='method'><a href="TableFields.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="TableFields.html#getFieldInfo">getFieldInfo</a></li><li data-type='method'><a href="TableFields.html#getNextSelectColumnNumber">getNextSelectColumnNumber</a></li><li data-type='method'><a href="TableFields.html#getSelectFieldColumn">getSelectFieldColumn</a></li><li data-type='method'><a href="TableFields.html#getSelectFields">getSelectFields</a></li><li data-type='method'><a href="TableFields.html#getTableInfo">getTableInfo</a></li><li data-type='method'><a href="TableFields.html#getTempSelectedColumnNumbers">getTempSelectedColumnNumbers</a></li><li data-type='method'><a href="TableFields.html#hasField">hasField</a></li><li data-type='method'><a href="TableFields.html#indexTableField">indexTableField</a></li><li data-type='method'><a href="TableFields.html#loadVirtualFields">loadVirtualFields</a></li><li data-type='method'><a href="TableFields.html#parseAstSelectField">parseAstSelectField</a></li><li data-type='method'><a href="TableFields.html#updateDerivedTableVirtualFields">updateDerivedTableVirtualFields</a></li><li data-type='method'><a href="TableFields.html#updateSelectFieldList">updateSelectFieldList</a></li><li data-type='method'><a href="TableFields.html#.getSelectCountModifiers">getSelectCountModifiers</a></li><li data-type='method'><a href="TableFields.html#.sortPrimaryFields">sortPrimaryFields</a></li></ul></li><li><a href="TestedStatements.html">TestedStatements</a><ul class='methods'><li data-type='method'><a href="TestedStatements.html#getTableDefinitionString">getTableDefinitionString</a></li></ul></li><li><a href="VirtualField.html">VirtualField</a></li><li><a href="VirtualFields.html">VirtualFields</a><ul class='methods'><li data-type='method'><a href="VirtualFields.html#add">add</a></li><li data-type='method'><a href="VirtualFields.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="VirtualFields.html#.expandWildcardFields">expandWildcardFields</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#SQLselfTest">SQLselfTest</a></li><li><a href="global.html#customMenuGenerateTests">customMenuGenerateTests</a></li><li><a href="global.html#gsSQL">gsSQL</a></li><li><a href="global.html#isEqual">isEqual</a></li><li><a href="global.html#onOpen">onOpen</a></li><li><a href="global.html#parseTableSettings">parseTableSettings</a></li><li><a href="global.html#sqlTestCases">sqlTestCases</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Sql.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//  Remove comments for testing in NODE
//  *** DEBUG START ***
export { Sql, gsSQL, parseTableSettings, BindData };
import { Table } from './Table.js';
import { TableData } from './TableData.js';
import { SqlParse } from './SimpleParser.js';
import { SelectTables } from './Views.js';

class Logger {
    static log(msg) {
        console.log(msg);
    }
}
//  *** DEBUG END  ***/

/**
 * Query any sheet range using standard SQL SELECT syntax.
 * EXAMPLE :  gsSQL("select * from expenses where type = ?1", "expenses", A1:B, true, "travel")
 * 
 * @param {String} statement - SQL string 
 * @param {...any} parms - "table name",  SheetRange, [..."table name", SheetRange], OutputTitles (true/false), [...Bind Variable] 
 * @returns {any[][]} - Double array of selected data.  First index ROW, Second index COLUMN.
 * @customfunction
 */
function gsSQL(statement, ...parms) {     //  skipcq: JS-0128
    const sqlCmd = new Sql();
    let columnTitle = true;
    let bindings = [];

    if (parms.length === 0 || (parms.length > 0 &amp;&amp; (Array.isArray(parms[0]) || parms[0] === ''))) {
        //  If first item of parms is an array, the parms are assumed to be:
        // @param {any[][]} tableArr - {{"tableName", "sheetRange", cacheSeconds, hasColumnTitle}; {"name","range",cache,true};...}"
        // @param {Boolean} columnTitle - TRUE will add column title to output (default=TRUE)
        // @param {...any} bindings - Bind variables to match '?' in SQL statement.
        const tableArr = parms.length > 0 ? parms[0] : [];

        const tableList = parseTableSettings(tableArr, statement);
        Logger.log(`gsSQL: tableList=${tableList}.  Statement=${statement}. List Len=${tableList.length}`);

        for (const tableDef of tableList) {
            sqlCmd.addTableData(tableDef[0], tableDef[1], tableDef[2], tableDef[3]);
        }
        columnTitle = parms.length > 1 ? parms[1] : true;

        for (let i = 2; i &lt; parms.length; i++) {
            bindings.push(parms[i]);
        }
    }
    else if (parms.length > 0 &amp;&amp; typeof parms[0] === 'string') {
        //  We expect:  "tableName", tableData[], ...["tableName", tableData[]], includeColumnOutput, ...bindings
        let i = 0;
        while (i+1 &lt; parms.length &amp;&amp; typeof parms[i] !== 'boolean') {
            Logger.log(`Add Table: ${parms[i]}. Items=${parms[i + 1].length}`);
            sqlCmd.addTableData(parms[i], parms[i+1], 0, true);
            i += 2;
        }
        if (i &lt; parms.length &amp;&amp; typeof parms[i] === 'boolean') {
            columnTitle = parms[i];
            i++
        }
        Logger.log(`Column Titles: ${columnTitle}`);
        while (i &lt; parms.length) {
            Logger.log(`Add BIND Variable: ${parms[i]}`);
            bindings.push(parms[i]);
            i++
        }
    }
    else {
        throw new Error("Invalid gsSQL() parameter list.");
    }

    sqlCmd.enableColumnTitle(columnTitle);

    for (const bind of bindings) {
        sqlCmd.addBindParameter(bind);
    }

    return sqlCmd.execute(statement);
}

/**
 * 
 * @param {any[][]} tableArr - Referenced Table list.  This is normally the second parameter in gsSQL() custom function.  
 * It is a double array with first index for TABLE, and the second index are settings in the table. 
 * The setting index for each table is as follows:
 * * 0 - Table Name.
 * * 1 - Sheet Range.
 * * 2 - Cache seconds.
 * * 3 - First row contains title (for field name)
 * @param {String} statement - SQL SELECT statement.  If no data specified in 'tableArr', the SELECT is 
 * parsed and each referenced table is assumed to be a TAB name on the sheet.
 * @param {Boolean} randomOrder - Returned table list is randomized.
 * @returns {any[][]} - Data from 'tableArr' PLUS any extracted tables referenced from SELECT statement.
 * It is a double array with first index for TABLE, and the second index are settings in the table. 
 * The setting index for each table is as follows:
 * * 0 - Table Name.
 * * 1 - Sheet Range.
 * * 2 - Cache seconds.
 * * 3 - First row contains title (for field name)
 */
function parseTableSettings(tableArr, statement = "", randomOrder = true) {
    let tableList = [];
    let referencedTableSettings = tableArr;

    //  Get table names from the SELECT statement when no table range info is given.
    if (tableArr.length === 0 &amp;&amp; statement !== "") {
        referencedTableSettings = Sql.getReferencedTableNames(statement);
    }

    if (referencedTableSettings.length === 0) {
        throw new Error('Missing table definition {{"name","range",cache};{...}}');
    }

    Logger.log(`tableArr = ${referencedTableSettings}`);
    for (/** @type {any[]} */ const table of referencedTableSettings) {
        if (table.length === 1)
            table.push(table[0]);   // if NO RANGE, assumes table name is sheet name.
        if (table.length === 2)
            table.push(60);      //  default 0 second cache.
        if (table.length === 3)
            table.push(true);    //  default HAS column title row.
        if (table[1] === "")
            table[1] = table[0];    //  If empty range, assumes TABLE NAME is the SHEET NAME and loads entire sheet.
        if (table.length !== 4)
            throw new Error("Invalid table definition [name,range,cache,hasTitle]");

        tableList.push(table);
    }

    //  If called at the same time, loading similar tables in similar order - all processes
    //  just wait for table - but if loaded in different order, each process could be loading something.
    if (randomOrder)
        tableList = tableList.sort(() => Math.random() - 0.5);

    return tableList;
}

/** Perform SQL SELECT using this class. */
class Sql {
    constructor() {
        /** @property {Map&lt;String,Table>} - Map of referenced tables.*/
        this.tables = new Map();
        /** @property {Boolean} - Are column tables to be ouptout? */
        this.columnTitle = false;
        /** @property {BindData} - List of BIND data linked to '?' in statement. */
        this.bindData = new BindData();
        /** @property {String} - derived table name to output in column title replacing source table name. */
        this.columnTableNameReplacement = null;
    }

    /**
     * Add data for each referenced table in SELECT, before EXECUTE().
     * @param {String} tableName - Name of table referenced in SELECT.
     * @param {any} tableData - Either double array or a named range.
     * @param {Number} cacheSeconds - How long should loaded data be cached (default=0)
     * @param {Boolean} hasColumnTitle - Is first data row the column title?
     * @returns {Sql}
     */
    addTableData(tableName, tableData, cacheSeconds = 0, hasColumnTitle = true) {
        let tableInfo = null;

        if (Array.isArray(tableData)) {
            tableInfo = new Table(tableName)
                .setHasColumnTitle(hasColumnTitle)
                .loadArrayData(tableData);
        }
        else {
            tableInfo = new Table(tableName)
                .setHasColumnTitle(hasColumnTitle)
                .loadNamedRangeData(tableData, cacheSeconds);
        }

        this.tables.set(tableName.toUpperCase(), tableInfo);

        return this;
    }

    /**
     * Copies the data from an external tableMap to this instance.  
     * It copies a reference to outside array data only.  
     * The schema would need to be re-loaded.
     * @param {Map&lt;String,Table>} tableMap 
     */
    copyTableData(tableMap) {
        // @ts-ignore
        for (const tableName of tableMap.keys()) {
            const tableInfo = tableMap.get(tableName);
            this.addTableData(tableName, tableInfo.tableData);
        }

        return this;
    }

    /**
     * Include column headers in return data.
     * @param {Boolean} value - true will return column names in first row of return data.
     * @returns {Sql}
     */
    enableColumnTitle(value) {
        this.columnTitle = value;
        return this;
    }

    /**
     * Derived table data that requires the ALIAS table name in column title.
     * @param {String} replacementTableName - derived table name to replace original table name.  To disable, set to null.
     * @returns {Sql}
     */
    replaceColumnTableNameWith(replacementTableName) {
        this.columnTableNameReplacement = replacementTableName;
        return this;
    }

    /**
     * Query if this instance of Sql() will generate column titles.
     * @returns {Boolean}
     */
    areColumnTitlesOutput() {
        return this.columnTitle;
    }

    /**
     * Add a bind data value.  Must be added in order.  If bind data is a named range, use addBindNamedRangeParameter().
     * @param {any} value - literal data. 
     * @returns {Sql}
     */
    addBindParameter(value) {
        this.bindData.add(value);
        return this;
    }

    /**
     * List of bind data added so far.
     * @returns {any[]}
     */
    getBindData() {
        return this.bindData.getBindDataList();
    }

    /**
     * The BIND data is a sheet named range that will be read and used for bind data.
     * @param {String} value - Sheets Named Range for SINGLE CELL only.
     * @returns {Sql}
     */
    addBindNamedRangeParameter(value) {
        const namedValue = TableData.getValueCached(value, 30);
        this.bindData.add(namedValue);
        Logger.log(`BIND=${value} = ${namedValue}`);
        return this;
    }

    /**
     * Set all bind data at once using array.
     * @param {BindData} value - Bind data.
     * @returns {Sql}
     */
    setBindValues(value) {
        this.bindData = value;
        return this;
    }

    /**
     * Clears existing BIND data so Sql() instance can be used again with new bind parameters.
     * @returns {Sql}
     */
    clearBindParameters() {
        this.bindData.clear();
        return this;
    }

    /**
    * Parse SQL SELECT statement, performs SQL query and returns data ready for custom function return.
    * &lt;br>Execute() can be called multiple times for different SELECT statements, provided that all required
    * table data was loaded in the constructor.  
    * Methods that would be used PRIOR to execute are:
    * &lt;br>**enableColumnTitle()** - turn on/off column title in output
    * &lt;br>**addBindParameter()** - If bind data is needed in select.  e.g. "select * from table where id = ?"
    * &lt;br>**addTableData()** - At least ONE table needs to be added prior to execute. This tells **execute** where to find the data.
    * &lt;br>**Example SELECT and RETURN Data**
    * ```js
    *   let stmt = "SELECT books.id, books.title, books.author_id " +
    *        "FROM books " +
    *        "WHERE books.author_id IN ('11','12') " +
    *        "ORDER BY books.title";
    *
    *    let data = new Sql()
    *        .addTableData("books", this.bookTable())
    *        .enableColumnTitle(true)
    *        .execute(stmt);
    * 
    *    Logger.log(data);
    * 
    * [["books.id", "books.title", "books.author_id"],
    *    ["4", "Dream Your Life", "11"],
    *    ["8", "My Last Book", "11"],
    *    ["5", "Oranges", "12"],
    *    ["1", "Time to Grow Up!", "11"]]
    * ```
    * @param {any} statement - SELECT statement as STRING or AST of SELECT statement.
    * @returns {any[][]} - Double array where first index is ROW and second index is COLUMN.
    */
    execute(statement) {
        let sqlData = [];

        this.ast = (typeof statement === 'string') ? SqlParse.sql2ast(statement) : statement;

        //  "SELECT * from (select a,b,c from table) as derivedtable"
        //  Sub query data is loaded and given the name 'derivedtable' (using ALIAS from AS)
        //  The AST.FROM is updated from the sub-query to the new derived table name. 
        this.selectFromSubQuery();

        //  A JOIN table can a sub-query.  When this is the case, the sub-query SELECT is
        //  evaluated and the return data is given the ALIAS (as) name.  The AST is then
        //  updated to use the new table.
        this.selectJoinSubQuery();

        Sql.setTableAlias(this.tables, this.ast);
        Sql.loadSchema(this.tables);

        if (typeof this.ast.SELECT !== 'undefined')
            sqlData = this.select(this.ast);
        else
            throw new Error("Only SELECT statements are supported.");

        return sqlData;
    }

    /**
     * Updates 'tables' with table column information.
     * @param {Map&lt;String,Table>} tables 
     */
    static loadSchema(tables) {
        // @ts-ignore
        for (const table of tables.keys()) {
            const tableInfo = tables.get(table.toUpperCase());
            tableInfo.loadSchema();
        }
    }

    /**
     * Updates 'tables' with associated table ALIAS name found in ast.
     * @param {Map&lt;String,Table>} tables 
     * @param {Object} ast 
     */
    static setTableAlias(tables, ast) {
        // @ts-ignore
        for (const table of tables.keys()) {
            const tableAlias = Sql.getTableAlias(table, ast);
            const tableInfo = tables.get(table.toUpperCase());
            tableInfo.setTableAlias(tableAlias);
        }
    }

    /**
     * Sets all tables referenced SELECT.
    * @param {Map&lt;String,Table>} mapOfTables - Map of referenced tables indexed by TABLE name.
    */
    setTables(mapOfTables) {
        this.tables = mapOfTables;
        return this;
    }

    /**
     * Returns a map of all tables configured for this SELECT.
     * @returns {Map&lt;String,Table>} - Map of referenced tables indexed by TABLE name.
     */
    getTables() {
        return this.tables;
    }

    /**
    * Find table alias name (if any) for input actual table name.
    * @param {String} tableName - Actual table name.
    * @param {Object} ast - Abstract Syntax Tree for SQL.
    * @returns {String} - Table alias.  Empty string if not found.
    */
    static getTableAlias(tableName, ast) {
        let tableAlias = "";
        const ucTableName = tableName.toUpperCase();

        tableAlias = Sql.getTableAliasFromJoin(tableAlias, ucTableName, ast);
        tableAlias = Sql.getTableAliasUnion(tableAlias, ucTableName, ast);
        tableAlias = Sql.getTableAliasWhereIn(tableAlias, ucTableName, ast);
        tableAlias = Sql.getTableAliasWhereTerms(tableAlias, ucTableName, ast);

        return tableAlias;
    }

    /**
     * Modifies AST when FROM is a sub-query rather than a table name.
     */
    selectFromSubQuery() {
        if (typeof this.ast.FROM !== 'undefined' &amp;&amp; typeof this.ast.FROM.SELECT !== 'undefined') {
            const data = new Sql()
                .setTables(this.tables)
                .enableColumnTitle(true)
                .replaceColumnTableNameWith(this.ast.FROM.table)
                .execute(this.ast.FROM);

            if (typeof this.ast.FROM.table !== 'undefined') {
                this.addTableData(this.ast.FROM.table, data);
            }

            if (this.ast.FROM.table === '') {
                throw new Error("Every derived table must have its own alias");
            }

            this.ast.FROM.as = '';
        }
    }

    /**
     * Checks if the JOINed table is a sub-query.  
     * The sub-query is evaluated and assigned the alias name.
     * The AST is adjusted to use the new JOIN TABLE.
     * @returns {void}
     */
    selectJoinSubQuery() {
        if (typeof this.ast.JOIN !== 'undefined') {
            for (const joinAst of this.ast.JOIN) {
                if (typeof joinAst.table !== 'string') {
                    const data = new Sql()
                        .setTables(this.tables)
                        .enableColumnTitle(true)
                        .replaceColumnTableNameWith(joinAst.as)
                        .execute(joinAst.table);

                    if (typeof joinAst.as !== 'undefined') {
                        this.addTableData(joinAst.as, data);
                    }

                    if (joinAst.as === '') {
                        throw new Error("Every derived table must have its own alias");
                    }
                    joinAst.table = joinAst.as;
                    joinAst.as = '';
                }
            }
        }
    }

    /**
     * Searches the FROM and JOIN components of a SELECT to find the table alias.
     * @param {String} tableAlias - Default alias name
     * @param {String} tableName - table name to search for.
     * @param {Object} ast - Abstract Syntax Tree to search
     * @returns {String} - Table alias name.
     */
    static getTableAliasFromJoin(tableAlias, tableName, ast) {
        const astTableBlocks = ['FROM', 'JOIN'];
        let aliasNameFound = tableAlias;

        let i = 0;
        while (aliasNameFound === "" &amp;&amp; i &lt; astTableBlocks.length) {
            aliasNameFound = Sql.locateAstTableAlias(tableName, ast, astTableBlocks[i]);
            i++;
        }

        return aliasNameFound;
    }

    /**
     * Searches the UNION portion of the SELECT to locate the table alias.
     * @param {String} tableAlias - default table alias.
     * @param {String} tableName - table name to search for.
     * @param {Object} ast - Abstract Syntax Tree to search
     * @returns {String} - table alias
     */
    static getTableAliasUnion(tableAlias, tableName, ast) {
        const astRecursiveTableBlocks = ['UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT'];
        let extractedAlias = tableAlias;

        let i = 0;
        while (extractedAlias === "" &amp;&amp; i &lt; astRecursiveTableBlocks.length) {
            if (typeof ast[astRecursiveTableBlocks[i]] !== 'undefined') {
                for (const unionAst of ast[astRecursiveTableBlocks[i]]) {
                    extractedAlias = Sql.getTableAlias(tableName, unionAst);

                    if (extractedAlias !== "")
                        break;
                }
            }
            i++;
        }

        return extractedAlias;
    }

    /**
     * Search WHERE IN component of SELECT to find table alias.
     * @param {String} tableAlias - default table alias
     * @param {String} tableName - table name to search for
     * @param {Object} ast - Abstract Syntax Tree to search
     * @returns {String} - table alias
     */
    static getTableAliasWhereIn(tableAlias, tableName, ast) {
        let extractedAlias = tableAlias;
        if (tableAlias === "" &amp;&amp; typeof ast.WHERE !== 'undefined' &amp;&amp; ast.WHERE.operator === "IN") {
            extractedAlias = Sql.getTableAlias(tableName, ast.WHERE.right);
        }

        if (extractedAlias === "" &amp;&amp; ast.operator === "IN") {
            extractedAlias = Sql.getTableAlias(tableName, ast.right);
        }

        return extractedAlias;
    }

    /**
     * Search WHERE terms of SELECT to find table alias.
     * @param {String} tableAlias - default table alias
     * @param {String} tableName  - table name to search for.
     * @param {Object} ast - Abstract Syntax Tree to search.
     * @returns {String} - table alias
     */
    static getTableAliasWhereTerms(tableAlias, tableName, ast) {
        let extractedTableAlias = tableAlias;
        if (tableAlias === "" &amp;&amp; typeof ast.WHERE !== 'undefined' &amp;&amp; typeof ast.WHERE.terms !== 'undefined') {
            for (const term of ast.WHERE.terms) {
                if (extractedTableAlias === "")
                    extractedTableAlias = Sql.getTableAlias(tableName, term);
            }
        }

        return extractedTableAlias;
    }

    /**
     * Create table definition array from select string.
     * @param {String} statement - full sql select statement.
     * @returns {String[][]} - table definition array.
     */
    static getReferencedTableNames(statement) {
        const ast = SqlParse.sql2ast(statement);
        return this.getReferencedTableNamesFromAst(ast);
    }

    /**
     * Create table definition array from select AST.
     * @param {Object} ast - AST for SELECT. 
     * @returns {any[]} - table definition array.
     * * [0] - table name.
     * * [1] - sheet tab name
     * * [2] - cache seconds
     * * [3] - output column title flag
     */
    static getReferencedTableNamesFromAst(ast) {
        const DEFAULT_CACHE_SECONDS = 60;
        const DEFAULT_COLUMNS_OUTPUT = true;
        const tableSet = new Map();

        Sql.extractAstTables(ast, tableSet);

        const tableList = [];
        // @ts-ignore
        for (const key of tableSet.keys()) {
            const tableDef = [key, key, DEFAULT_CACHE_SECONDS, DEFAULT_COLUMNS_OUTPUT];

            tableList.push(tableDef);
        }

        return tableList;
    }

    /**
     * Search for all referenced tables in SELECT.
     * @param {Object} ast - AST for SELECT.
     * @param {Map&lt;String,String>} tableSet  - Function updates this map of table names and alias name.
     */
    static extractAstTables(ast, tableSet) {
        Sql.getTableNamesFrom(ast, tableSet);
        Sql.getTableNamesJoin(ast, tableSet);
        Sql.getTableNamesUnion(ast, tableSet);
        Sql.getTableNamesWhereIn(ast, tableSet);
        Sql.getTableNamesWhereTerms(ast, tableSet);
        Sql.getTableNamesCorrelatedSelect(ast, tableSet);
    }

    /**
     * Search for referenced table in FROM or JOIN part of select.
     * @param {Object} ast - AST for SELECT.
     * @param {Map&lt;String,String>} tableSet  - Function updates this map of table names and alias name.
     */
    static getTableNamesFrom(ast, tableSet) {
        let fromAst = ast.FROM;
        while (typeof fromAst !== 'undefined') {
            if (typeof fromAst.isDerived === 'undefined') {
                tableSet.set(fromAst.table.toUpperCase(), typeof fromAst.as === 'undefined' ? '' : fromAst.as.toUpperCase());
            }
            else {
                Sql.extractAstTables(fromAst.FROM, tableSet);
            }
            fromAst = fromAst.FROM;
        }
    }

    /**
    * Search for referenced table in FROM or JOIN part of select.
    * @param {Object} ast - AST for SELECT.
    * @param {Map&lt;String,String>} tableSet  - Function updates this map of table names and alias name.
    */
    static getTableNamesJoin(ast, tableSet) {

        if (typeof ast.JOIN === 'undefined')
            return;

        for (const astItem of ast.JOIN) {
            if (typeof astItem.table === 'string') {
                tableSet.set(astItem.table.toUpperCase(), typeof astItem.as === 'undefined' ? '' : astItem.as.toUpperCase());
            }
            else {
                Sql.extractAstTables(astItem.table, tableSet);
            }
        }
    }

    /**
     * Check if input is iterable.
     * @param {any} input - Check this object to see if it can be iterated. 
     * @returns {Boolean} - true - can be iterated.  false - cannot be iterated.
     */
    static isIterable(input) {
        if (input === null || input === undefined) {
            return false
        }

        return typeof input[Symbol.iterator] === 'function'
    }

    /**
     * Searches for table names within SELECT (union, intersect, except) statements.
     * @param {Object} ast - AST for SELECT
     * @param {Map&lt;String,String>} tableSet - Function updates this map of table names and alias name.
     */
    static getTableNamesUnion(ast, tableSet) {
        const astRecursiveTableBlocks = ['UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT'];

        for (const block of astRecursiveTableBlocks) {
            if (typeof ast[block] !== 'undefined') {
                for (const unionAst of ast[block]) {
                    this.extractAstTables(unionAst, tableSet);
                }
            }
        }
    }

    /**
     * Searches for tables names within SELECT (in, exists) statements.
     * @param {Object} ast - AST for SELECT
     * @param {Map&lt;String,String>} tableSet - Function updates this map of table names and alias name.
     */
    static getTableNamesWhereIn(ast, tableSet) {
        //  where IN ().
        const subQueryTerms = ["IN", "NOT IN", "EXISTS", "NOT EXISTS"]
        if (typeof ast.WHERE !== 'undefined' &amp;&amp; (subQueryTerms.indexOf(ast.WHERE.operator) !== -1)) {
            this.extractAstTables(ast.WHERE.right, tableSet);
        }

        if (subQueryTerms.indexOf(ast.operator) !== -1) {
            this.extractAstTables(ast.right, tableSet);
        }
    }

    /**
     * Search WHERE to find referenced table names.
     * @param {Object} ast -  AST to search.
     * @param {Map&lt;String,String>} tableSet - Function updates this map of table names and alias name.
     */
    static getTableNamesWhereTerms(ast, tableSet) {
        if (typeof ast.WHERE !== 'undefined' &amp;&amp; typeof ast.WHERE.terms !== 'undefined') {
            for (const term of ast.WHERE.terms) {
                this.extractAstTables(term, tableSet);
            }
        }
    }

    /**
     * Search for table references in the WHERE condition.
     * @param {Object} ast -  AST to search.
     * @param {Map&lt;String,String>} tableSet - Function updates this map of table names and alias name. 
     */
    static getTableNamesWhereCondition(ast, tableSet) {
        const lParts = typeof ast.left === 'string' ? ast.left.split(".") : [];
        if (lParts.length > 1) {
            tableSet.set(lParts[0].toUpperCase(), "");
        }
        const rParts = typeof ast.right === 'string' ? ast.right.split(".") : [];
        if (rParts.length > 1) {
            tableSet.set(rParts[0].toUpperCase(), "");
        }
        if (typeof ast.terms !== 'undefined') {
            for (const term of ast.terms) {
                Sql.getTableNamesWhereCondition(term, tableSet);
            }
        }
    }

    /**
     * Search CORRELATES sub-query for table names.
     * @param {*} ast - AST to search
     * @param {*} tableSet - Function updates this map of table names and alias name.
     */
    static getTableNamesCorrelatedSelect(ast, tableSet) {
        if (typeof ast.SELECT !== 'undefined') {
            for (const term of ast.SELECT) {
                if (typeof term.subQuery !== 'undefined' &amp;&amp; term.subQuery !== null) {
                    this.extractAstTables(term.subQuery, tableSet);
                }
            }
        }
    }

    /**
     * Search a property of AST for table alias name.
     * @param {String} tableName - Table name to find in AST.
     * @param {Object} ast - AST of SELECT.
     * @param {String} astBlock - AST property to search.
     * @returns {String} - Alias name or "" if not found.
     */
    static locateAstTableAlias(tableName, ast, astBlock) {
        if (typeof ast[astBlock] === 'undefined')
            return "";

        let block = [ast[astBlock]];
        if (this.isIterable(ast[astBlock])) {
            block = ast[astBlock];
        }

        for (const astItem of block) {
            if (typeof astItem.table === 'string' &amp;&amp; tableName === astItem.table.toUpperCase() &amp;&amp; astItem.as !== "") {
                return astItem.as;
            }
        }

        return "";
    }

    /**
     * Load SELECT data and return in double array.
     * @param {Object} selectAst - Abstract Syntax Tree of SELECT
     * @returns {any[][]} - double array useable by Google Sheet in custom function return value.
     * * First row of data will be column name if column title output was requested.
     * * First Array Index - ROW
     * * Second Array Index - COLUMN
     */
    select(selectAst) {
        let recordIDs = [];
        let viewTableData = [];
        let ast = selectAst;

        if (typeof ast.FROM === 'undefined')
            throw new Error("Missing keyword FROM");

        //  Manipulate AST to add GROUP BY if DISTINCT keyword.
        ast = Sql.distinctField(ast);

        //  Manipulate AST add pivot fields.
        ast = this.pivotField(ast);

        const view = new SelectTables(ast, this.tables, this.bindData);

        //  JOIN tables to create a derived table.
        view.join(ast);                 // skipcq: JS-D008

        view.updateSelectedFields(ast);

        //  Get the record ID's of all records matching WHERE condition.
        recordIDs = view.whereCondition(ast);

        //  Get selected data records.
        viewTableData = view.getViewData(recordIDs);

        //  Compress the data.
        viewTableData = view.groupBy(ast, viewTableData);

        //  Sort our selected data.
        view.orderBy(ast, viewTableData);

        //  Remove fields referenced but not included in SELECT field list.
        view.removeTempColumns(viewTableData);

        if (typeof ast.LIMIT !== 'undefined') {
            const maxItems = ast.LIMIT.nb;
            if (viewTableData.length > maxItems)
                viewTableData.splice(maxItems);
        }

        //  Apply SET rules for various union types.
        viewTableData = this.unionSets(ast, viewTableData);

        if (this.columnTitle) {
            viewTableData.unshift(view.getColumnTitles(this.columnTableNameReplacement));
        }

        if (viewTableData.length === 0) {
            viewTableData.push([""]);
        }

        if (viewTableData.length === 1 &amp;&amp; viewTableData[0].length === 0) {
            viewTableData[0] = [""];
        }

        return viewTableData;
    }

    /**
     * If 'GROUP BY' is not set and 'DISTINCT' column is specified, update AST to add 'GROUP BY'.
     * @param {Object} ast - Abstract Syntax Tree for SELECT.
     * @returns {Object} - Updated AST to include GROUP BY when DISTINCT field used.
     */
    static distinctField(ast) {
        const astFields = ast.SELECT;

        if (astFields.length > 0) {
            const firstField = astFields[0].name.toUpperCase();
            if (firstField.startsWith("DISTINCT")) {
                astFields[0].name = firstField.replace("DISTINCT", "").trim();

                if (typeof ast['GROUP BY'] === 'undefined') {
                    const groupBy = [];

                    for (const astItem of astFields) {
                        groupBy.push({ name: astItem.name, as: '' });
                    }

                    ast["GROUP BY"] = groupBy;
                }
            }
        }

        return ast;
    }

    /**
     * Add new column to AST for every AGGREGATE function and unique pivot column data.
     * @param {Object} ast - AST which is checked to see if a PIVOT is used.
     * @returns {Object} - Updated AST containing SELECT FIELDS for the pivot data OR original AST if no pivot.
     */
    pivotField(ast) {
        //  If we are doing a PIVOT, it then requires a GROUP BY.
        if (typeof ast.PIVOT !== 'undefined') {
            if (typeof ast['GROUP BY'] === 'undefined')
                throw new Error("PIVOT requires GROUP BY");
        }
        else
            return ast;

        // These are all of the unique PIVOT field data points.
        const pivotFieldData = this.getUniquePivotData(ast);

        ast.SELECT = Sql.addCalculatedPivotFieldsToAst(ast, pivotFieldData);

        return ast;
    }

    /**
     * Find distinct pivot column data.
     * @param {Object} ast - Abstract Syntax Tree containing the PIVOT option.
     * @returns {any[][]} - All unique data points found in the PIVOT field for the given SELECT.
     */
    getUniquePivotData(ast) {
        const pivotAST = {};

        pivotAST.SELECT = ast.PIVOT;
        pivotAST.SELECT[0].name = `DISTINCT ${pivotAST.SELECT[0].name}`;
        pivotAST.FROM = ast.FROM;
        pivotAST.WHERE = ast.WHERE;

        const pivotSql = new Sql()
            .enableColumnTitle(false)
            .setBindValues(this.bindData)
            .copyTableData(this.getTables());

        // These are all of the unique PIVOT field data points.
        const tableData = pivotSql.execute(pivotAST);

        return tableData;
    }

    /**
     * Add new calculated fields to the existing SELECT fields.  A field is add for each combination of
     * aggregate function and unqiue pivot data points.  The CASE function is used for each new field.
     * A test is made if the column data equal the pivot data.  If it is, the aggregate function data 
     * is returned, otherwise null.  The GROUP BY is later applied and the appropiate pivot data will
     * be calculated.
     * @param {Object} ast - AST to be updated.
     * @param {any[][]} pivotFieldData - Table data with unique pivot field data points. 
     * @returns {Object} - Abstract Sytax Tree with new SELECT fields with a CASE for each pivot data and aggregate function.
     */
    static addCalculatedPivotFieldsToAst(ast, pivotFieldData) {
        const newPivotAstFields = [];

        for (const selectField of ast.SELECT) {
            //  If this is an aggregrate function, we will add one for every pivotFieldData item
            const functionNameRegex = /^\w+\s*(?=\()/;
            const matches = selectField.name.match(functionNameRegex)
            if (matches !== null &amp;&amp; matches.length > 0) {
                const args = SelectTables.parseForFunctions(selectField.name, matches[0].trim());

                for (const fld of pivotFieldData) {
                    const caseTxt = `${matches[0]}(CASE WHEN ${ast.PIVOT[0].name} = '${fld}' THEN ${args[1]} ELSE 'null' END)`;
                    const asField = `${fld[0]} ${typeof selectField.as !== 'undefined' &amp;&amp; selectField.as !== "" ? selectField.as : selectField.name}`;
                    newPivotAstFields.push({ name: caseTxt, as: asField });
                }
            }
            else
                newPivotAstFields.push(selectField);
        }

        return newPivotAstFields;
    }

    /**
     * If any SET commands are found (like UNION, INTERSECT,...) the additional SELECT is done.  The new
     * data applies the SET rule against the income viewTableData, and the result data set is returned.
     * @param {Object} ast - SELECT AST.
     * @param {any[][]} viewTableData - SELECTED data before UNION.
     * @returns {any[][]} - New data with set rules applied.
     */
    unionSets(ast, viewTableData) {
        const unionTypes = ['UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT'];
        let unionTableData = viewTableData;

        for (const type of unionTypes) {
            if (typeof ast[type] !== 'undefined') {
                const unionSQL = new Sql()
                    .setBindValues(this.bindData)
                    .copyTableData(this.getTables());
                for (const union of ast[type]) {
                    const unionData = unionSQL.execute(union);
                    if (unionTableData.length > 0 &amp;&amp; unionData.length > 0 &amp;&amp; unionTableData[0].length !== unionData[0].length)
                        throw new Error(`Invalid ${type}.  Selected field counts do not match.`);

                    switch (type) {
                        case "UNION":
                            //  Remove duplicates.
                            unionTableData = Sql.appendUniqueRows(unionTableData, unionData);
                            break;

                        case "UNION ALL":
                            //  Allow duplicates.
                            unionTableData = unionTableData.concat(unionData);
                            break;

                        case "INTERSECT":
                            //  Must exist in BOTH tables.
                            unionTableData = Sql.intersectRows(unionTableData, unionData);
                            break;

                        case "EXCEPT":
                            //  Remove from first table all rows that match in second table.
                            unionTableData = Sql.exceptRows(unionTableData, unionData);
                            break;

                        default:
                            throw new Error(`Internal error.  Unsupported UNION type: ${type}`);
                    }
                }
            }
        }

        return unionTableData;
    }

    /**
     * Appends any row in newData that does not exist in srcData.
     * @param {any[][]} srcData - existing table data
     * @param {any[][]} newData - new table data
     * @returns {any[][]} - srcData rows PLUS any row in newData that is NOT in srcData.
     */
    static appendUniqueRows(srcData, newData) {
        const srcMap = new Map();

        for (const srcRow of srcData) {
            srcMap.set(srcRow.join("::"), true);
        }

        for (const newRow of newData) {
            const key = newRow.join("::");
            if (!srcMap.has(key)) {
                srcData.push(newRow);
                srcMap.set(key, true);
            }
        }
        return srcData;
    }

    /**
     * Finds the rows that are common between srcData and newData
     * @param {any[][]} srcData - table data
     * @param {any[][]} newData - table data
     * @returns {any[][]} - returns only rows that intersect srcData and newData.
     */
    static intersectRows(srcData, newData) {
        const srcMap = new Map();
        const intersectTable = [];

        for (const srcRow of srcData) {
            srcMap.set(srcRow.join("::"), true);
        }

        for (const newRow of newData) {
            if (srcMap.has(newRow.join("::"))) {
                intersectTable.push(newRow);
            }
        }
        return intersectTable;
    }

    /**
     * Returns all rows in srcData MINUS any rows that match it from newData.
     * @param {any[][]} srcData - starting table
     * @param {any[][]} newData  - minus table (if it matches srcData row)
     * @returns {any[][]} - srcData MINUS newData
     */
    static exceptRows(srcData, newData) {
        const srcMap = new Map();
        let rowNum = 0;
        for (const srcRow of srcData) {
            srcMap.set(srcRow.join("::"), rowNum);
            rowNum++;
        }

        const removeRowNum = [];
        for (const newRow of newData) {
            const key = newRow.join("::");
            if (srcMap.has(key)) {
                removeRowNum.push(srcMap.get(key));
            }
        }

        removeRowNum.sort(function (a, b) { return b - a });
        for (rowNum of removeRowNum) {
            srcData.splice(rowNum, 1);
        }

        return srcData;
    }
}

/**
 * Store and retrieve bind data for use in WHERE portion of SELECT statement.
 */
class BindData {
    constructor() {
        this.clear();
    }

    /**
     * Reset the bind data.
     */
    clear() {
        this.next = 1;
        this.bindMap = new Map();
        this.bindQueue = [];
    }

    /**
     * Add bind data 
     * @param {any} data - bind data
     * @returns {String} - bind variable name for reference in SQL.  e.g.  first data point would return '?1'.
     */
    add(data) {
        const key = `?${this.next.toString()}`;
        this.bindMap.set(key, data);
        this.bindQueue.push(data);

        this.next++;

        return key;
    }

    /**
     * Add a list of bind data points.
     * @param {any[]} bindList 
     */
    addList(bindList) {
        for (const data of bindList) {
            this.add(data);
        }
    }

    /**
     * Pull out a bind data entry.
     * @param {String} name - Get by name or get NEXT if empty.
     * @returns {any}
     */
    get(name = "") {
        return name === '' ? this.bindQueue.shift() : this.bindMap.get(name);
    }

    /**
     * Return the ordered list of bind data.
     * @returns {any[]} - Current list of bind data.
     */
    getBindDataList() {
        return this.bindQueue;
    }
}

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Wed Mar 08 2023 21:07:57 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
