<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>SimpleParser.js - gsSQL</title>
    
    <meta name="description" content="Query Google Sheets using standard SQL SELECT syntax." />
    
        <meta name="keywords" content="Google, Sheets, Query, SQL, SELECT" />
        <meta name="keyword" content="Google, Sheets, Query, SQL, SELECT" />
    
    
    
    <meta property="og:title" content="gsSQL Sheets Custom Function"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://demmings.github.io/img/logo.png"/>
    <meta property="og:site_name" content="gsSQL"/>
    <meta property="og:url" content="https://demmings.github.io/"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://demmings.github.io" target="_blank" class="menu-item" id="website_link" >Project Website</a></h2><h2><a href="https://github.com/demmings/gsSQL" target="_blank" class="menu-item" id="website_link" >Github Website</a></h2><h3>Classes</h3><ul><li><a href="AggregateTrack.html">AggregateTrack</a><ul class='methods'><li data-type='method'><a href="AggregateTrack.html#addGroupConcatItem">addGroupConcatItem</a></li><li data-type='method'><a href="AggregateTrack.html#count">count</a></li><li data-type='method'><a href="AggregateTrack.html#getAverage">getAverage</a></li><li data-type='method'><a href="AggregateTrack.html#getGroupConcat">getGroupConcat</a></li><li data-type='method'><a href="AggregateTrack.html#maxCase">maxCase</a></li><li data-type='method'><a href="AggregateTrack.html#minCase">minCase</a></li><li data-type='method'><a href="AggregateTrack.html#sum">sum</a></li></ul></li><li><a href="BindData.html">BindData</a><ul class='methods'><li data-type='method'><a href="BindData.html#add">add</a></li><li data-type='method'><a href="BindData.html#addList">addList</a></li><li data-type='method'><a href="BindData.html#clear">clear</a></li><li data-type='method'><a href="BindData.html#get">get</a></li><li data-type='method'><a href="BindData.html#getBindDataList">getBindDataList</a></li></ul></li><li><a href="CalculatedField.html">CalculatedField</a><ul class='methods'><li data-type='method'><a href="CalculatedField.html#createAssignmentStatments">createAssignmentStatments</a></li><li data-type='method'><a href="CalculatedField.html#evaluateCalculatedField">evaluateCalculatedField</a></li><li data-type='method'><a href="CalculatedField.html#getData">getData</a></li><li data-type='method'><a href="CalculatedField.html#sqlServerCalcFields">sqlServerCalcFields</a></li><li data-type='method'><a href="CalculatedField.html#sqlServerFunctions">sqlServerFunctions</a></li></ul></li><li><a href="CondLexer.html">CondLexer</a><ul class='methods'><li data-type='method'><a href="CondLexer.html#isFinishedWord">isFinishedWord</a></li><li data-type='method'><a href="CondLexer.html#isStartOrEndOfString">isStartOrEndOfString</a></li><li data-type='method'><a href="CondLexer.html#readBindVariable">readBindVariable</a></li><li data-type='method'><a href="CondLexer.html#readGroupSymbol">readGroupSymbol</a></li><li data-type='method'><a href="CondLexer.html#readMathOperator">readMathOperator</a></li><li data-type='method'><a href="CondLexer.html#readNextToken">readNextToken</a></li><li data-type='method'><a href="CondLexer.html#readOperator">readOperator</a></li><li data-type='method'><a href="CondLexer.html#readString">readString</a></li><li data-type='method'><a href="CondLexer.html#readWord">readWord</a></li></ul></li><li><a href="CondParser.html">CondParser</a><ul class='methods'><li data-type='method'><a href="CondParser.html#parseBaseExpression">parseBaseExpression</a></li><li data-type='method'><a href="CondParser.html#parseConditionExpression">parseConditionExpression</a></li><li data-type='method'><a href="CondParser.html#parseExpressionsRecursively">parseExpressionsRecursively</a></li><li data-type='method'><a href="CondParser.html#parseGroupExpression">parseGroupExpression</a></li><li data-type='method'><a href="CondParser.html#parseLogicalExpression">parseLogicalExpression</a></li><li data-type='method'><a href="CondParser.html#parseSelectExistsSubQuery">parseSelectExistsSubQuery</a></li><li data-type='method'><a href="CondParser.html#parseSelectIn">parseSelectIn</a></li><li data-type='method'><a href="CondParser.html#parseWordExpression">parseWordExpression</a></li><li data-type='method'><a href="CondParser.html#readNextToken">readNextToken</a></li><li data-type='method'><a href="CondParser.html#.groupBracketIncrementer">groupBracketIncrementer</a></li><li data-type='method'><a href="CondParser.html#.parse">parse</a></li></ul></li><li><a href="ConglomerateRecord.html">ConglomerateRecord</a><ul class='methods'><li data-type='method'><a href="ConglomerateRecord.html#squish">squish</a></li><li data-type='method'><a href="ConglomerateRecord.html#.aggregateColumn">aggregateColumn</a></li><li data-type='method'><a href="ConglomerateRecord.html#.aggregateColumnToNumeric">aggregateColumnToNumeric</a></li></ul></li><li><a href="CorrelatedSubQuery.html">CorrelatedSubQuery</a><ul class='methods'><li data-type='method'><a href="CorrelatedSubQuery.html#replaceOuterFieldValueInCorrelatedWhere">replaceOuterFieldValueInCorrelatedWhere</a></li><li data-type='method'><a href="CorrelatedSubQuery.html#select">select</a></li><li data-type='method'><a href="CorrelatedSubQuery.html#traverseWhere">traverseWhere</a></li></ul></li><li><a href="DerivedTable.html">DerivedTable</a><ul class='methods'><li data-type='method'><a href="DerivedTable.html#createTable">createTable</a></li><li data-type='method'><a href="DerivedTable.html#getTableData">getTableData</a></li><li data-type='method'><a href="DerivedTable.html#isDerivedTable">isDerivedTable</a></li><li data-type='method'><a href="DerivedTable.html#setIsOuterJoin">setIsOuterJoin</a></li><li data-type='method'><a href="DerivedTable.html#setLeftField">setLeftField</a></li><li data-type='method'><a href="DerivedTable.html#setLeftRecords">setLeftRecords</a></li><li data-type='method'><a href="DerivedTable.html#setRightField">setRightField</a></li><li data-type='method'><a href="DerivedTable.html#.getCombinedColumnTitles">getCombinedColumnTitles</a></li></ul></li><li><a href="FieldComparisons.html">FieldComparisons</a><ul class='methods'><li data-type='method'><a href="FieldComparisons.html#.existsCondition">existsCondition</a></li><li data-type='method'><a href="FieldComparisons.html#.getComparisonFunction">getComparisonFunction</a></li><li data-type='method'><a href="FieldComparisons.html#.inCondition">inCondition</a></li><li data-type='method'><a href="FieldComparisons.html#.isCondition">isCondition</a></li><li data-type='method'><a href="FieldComparisons.html#.likeCondition">likeCondition</a></li><li data-type='method'><a href="FieldComparisons.html#.likeConditionMatch">likeConditionMatch</a></li><li data-type='method'><a href="FieldComparisons.html#.notLikeCondition">notLikeCondition</a></li></ul></li><li><a href="GasSql.html">GasSql</a><ul class='methods'><li data-type='method'><a href="GasSql.html#.execute">execute</a></li><li data-type='method'><a href="GasSql.html#.executeSqlv1">executeSqlv1</a></li><li data-type='method'><a href="GasSql.html#.executeSqlv2">executeSqlv2</a></li><li data-type='method'><a href="GasSql.html#.parseTableSettings">parseTableSettings</a></li></ul></li><li><a href="JoinTables.html">JoinTables</a><ul class='methods'><li data-type='method'><a href="JoinTables.html#getJoinedTableInfo">getJoinedTableInfo</a></li><li data-type='method'><a href="JoinTables.html#isDerivedTable">isDerivedTable</a></li><li data-type='method'><a href="JoinTables.html#joinCondition">joinCondition</a></li><li data-type='method'><a href="JoinTables.html#joinNextTable">joinNextTable</a></li><li data-type='method'><a href="JoinTables.html#load">load</a></li><li data-type='method'><a href="JoinTables.html#resolveCondition">resolveCondition</a></li><li data-type='method'><a href="JoinTables.html#setBindVariables">setBindVariables</a></li><li data-type='method'><a href="JoinTables.html#setPrimaryTableInfo">setPrimaryTableInfo</a></li><li data-type='method'><a href="JoinTables.html#setTableFields">setTableFields</a></li><li data-type='method'><a href="JoinTables.html#setTableInfo">setTableInfo</a></li><li data-type='method'><a href="JoinTables.html#.andJoinIds">andJoinIds</a></li><li data-type='method'><a href="JoinTables.html#.joinTables">joinTables</a></li><li data-type='method'><a href="JoinTables.html#.orJoinIds">orJoinIds</a></li></ul></li><li><a href="JoinTablesRecordIds.html">JoinTablesRecordIds</a><ul class='methods'><li data-type='method'><a href="JoinTablesRecordIds.html#createKeyFieldRecordMap">createKeyFieldRecordMap</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getJoinColumnData">getJoinColumnData</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getJoinFieldsInfo">getJoinFieldsInfo</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getLeftRightFieldInfo">getLeftRightFieldInfo</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getMatchedRecordIds">getMatchedRecordIds</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getRecordIDs">getRecordIDs</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getReferencedTableInfo">getReferencedTableInfo</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#getTableInfoFromCalculatedField">getTableInfoFromCalculatedField</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#leftRightJoin">leftRightJoin</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#searchColumnsForTable">searchColumnsForTable</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setBindVariables">setBindVariables</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setJoinType">setJoinType</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setLeftTableName">setLeftTableName</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setPrimaryTableInfo">setPrimaryTableInfo</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setRightTableName">setRightTableName</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setTableFields">setTableFields</a></li><li data-type='method'><a href="JoinTablesRecordIds.html#setTableInfo">setTableInfo</a></li></ul></li><li><a href="PropertyData.html">PropertyData</a><ul class='methods'><li data-type='method'><a href="PropertyData.html#.getData">getData</a></li><li data-type='method'><a href="PropertyData.html#.isExpired">isExpired</a></li></ul></li><li><a href="Schema.html">Schema</a><ul class='methods'><li data-type='method'><a href="Schema.html#getAllExtendedNotationFieldNames">getAllExtendedNotationFieldNames</a></li><li data-type='method'><a href="Schema.html#getAllFieldNames">getAllFieldNames</a></li><li data-type='method'><a href="Schema.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="Schema.html#getColumnNameVariants">getColumnNameVariants</a></li><li data-type='method'><a href="Schema.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="Schema.html#getFieldColumns">getFieldColumns</a></li><li data-type='method'><a href="Schema.html#load">load</a></li><li data-type='method'><a href="Schema.html#setFieldVariantsColumNumber">setFieldVariantsColumNumber</a></li><li data-type='method'><a href="Schema.html#setTable">setTable</a></li><li data-type='method'><a href="Schema.html#setTableAlias">setTableAlias</a></li><li data-type='method'><a href="Schema.html#setTableData">setTableData</a></li><li data-type='method'><a href="Schema.html#setTableName">setTableName</a></li></ul></li><li><a href="ScriptSettings.html">ScriptSettings</a><ul class='methods'><li data-type='method'><a href="ScriptSettings.html#delete">delete</a></li><li data-type='method'><a href="ScriptSettings.html#expire">expire</a></li><li data-type='method'><a href="ScriptSettings.html#get">get</a></li><li data-type='method'><a href="ScriptSettings.html#put">put</a></li><li data-type='method'><a href="ScriptSettings.html#putAll">putAll</a></li></ul></li><li><a href="Select2Object.html">Select2Object</a><ul class='methods'><li data-type='method'><a href="Select2Object.html#addBindVariable">addBindVariable</a></li><li data-type='method'><a href="Select2Object.html#addTableData">addTableData</a></li><li data-type='method'><a href="Select2Object.html#execute">execute</a></li><li data-type='method'><a href="Select2Object.html#.cleanupColumnNames">cleanupColumnNames</a></li><li data-type='method'><a href="Select2Object.html#.createEmptyRecordObject">createEmptyRecordObject</a></li><li data-type='method'><a href="Select2Object.html#.createTableObjectArray">createTableObjectArray</a></li></ul></li><li><a href="SelectKeywordAnalysis.html">SelectKeywordAnalysis</a><ul class='methods'><li data-type='method'><a href="SelectKeywordAnalysis.html#.EXCEPT">EXCEPT</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.FROM">FROM</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.FULL_JOIN">FULL_JOIN</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.GROUP_BY">GROUP_BY</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.HAVING">HAVING</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.INNER_JOIN">INNER_JOIN</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.INTERSECT">INTERSECT</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.LEFT_JOIN">LEFT_JOIN</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.LIMIT">LIMIT</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.ORDER_BY">ORDER_BY</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.PIVOT">PIVOT</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.RIGHT_JOIN">RIGHT_JOIN</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.SELECT">SELECT</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.UNION">UNION</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.UNION_ALL">UNION_ALL</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.WHERE">WHERE</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.allJoins">allJoins</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.analyze">analyze</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.extractSelectField">extractSelectField</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.getNameAndAlias">getNameAndAlias</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.lastIndexOfOutsideLiteral">lastIndexOfOutsideLiteral</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.parseForCorrelatedSubQuery">parseForCorrelatedSubQuery</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.protect_split">protect_split</a></li><li data-type='method'><a href="SelectKeywordAnalysis.html#.trim">trim</a></li></ul></li><li><a href="SelectTables.html">SelectTables</a><ul class='methods'><li data-type='method'><a href="SelectTables.html#createGroupByKey">createGroupByKey</a></li><li data-type='method'><a href="SelectTables.html#getColumnTitles">getColumnTitles</a></li><li data-type='method'><a href="SelectTables.html#getRecordIDs">getRecordIDs</a></li><li data-type='method'><a href="SelectTables.html#getViewData">getViewData</a></li><li data-type='method'><a href="SelectTables.html#groupBy">groupBy</a></li><li data-type='method'><a href="SelectTables.html#groupByFields">groupByFields</a></li><li data-type='method'><a href="SelectTables.html#having">having</a></li><li data-type='method'><a href="SelectTables.html#join">join</a></li><li data-type='method'><a href="SelectTables.html#orderBy">orderBy</a></li><li data-type='method'><a href="SelectTables.html#removeTempColumns">removeTempColumns</a></li><li data-type='method'><a href="SelectTables.html#resolveBindData">resolveBindData</a></li><li data-type='method'><a href="SelectTables.html#resolveCondition">resolveCondition</a></li><li data-type='method'><a href="SelectTables.html#resolveFieldCondition">resolveFieldCondition</a></li><li data-type='method'><a href="SelectTables.html#resolveSubQuery">resolveSubQuery</a></li><li data-type='method'><a href="SelectTables.html#updateSelectedFields">updateSelectedFields</a></li><li data-type='method'><a href="SelectTables.html#whereCondition">whereCondition</a></li><li data-type='method'><a href="SelectTables.html#.checkIfWithinString">checkIfWithinString</a></li><li data-type='method'><a href="SelectTables.html#.dateToMs">dateToMs</a></li><li data-type='method'><a href="SelectTables.html#.extractStringConstant">extractStringConstant</a></li><li data-type='method'><a href="SelectTables.html#.functionBracketCounter">functionBracketCounter</a></li><li data-type='method'><a href="SelectTables.html#.getConditionValue">getConditionValue</a></li><li data-type='method'><a href="SelectTables.html#.getSubQueryTableSet">getSubQueryTableSet</a></li><li data-type='method'><a href="SelectTables.html#.isCorrelatedSubQuery">isCorrelatedSubQuery</a></li><li data-type='method'><a href="SelectTables.html#.isStringConstant">isStringConstant</a></li><li data-type='method'><a href="SelectTables.html#.limit">limit</a></li><li data-type='method'><a href="SelectTables.html#.parseForFunctions">parseForFunctions</a></li><li data-type='method'><a href="SelectTables.html#.parseForParams">parseForParams</a></li><li data-type='method'><a href="SelectTables.html#.sortByColumnASC">sortByColumnASC</a></li><li data-type='method'><a href="SelectTables.html#.sortByColumnDESC">sortByColumnDESC</a></li><li data-type='method'><a href="SelectTables.html#.toUpperCaseExceptQuoted">toUpperCaseExceptQuoted</a></li></ul></li><li><a href="Sql.html">Sql</a><ul class='methods'><li data-type='method'><a href="Sql.html#addBindNamedRangeParameter">addBindNamedRangeParameter</a></li><li data-type='method'><a href="Sql.html#addBindParameter">addBindParameter</a></li><li data-type='method'><a href="Sql.html#addColumnTitles">addColumnTitles</a></li><li data-type='method'><a href="Sql.html#addTableData">addTableData</a></li><li data-type='method'><a href="Sql.html#areColumnTitlesOutput">areColumnTitlesOutput</a></li><li data-type='method'><a href="Sql.html#clearBindParameters">clearBindParameters</a></li><li data-type='method'><a href="Sql.html#copyTableData">copyTableData</a></li><li data-type='method'><a href="Sql.html#enableColumnTitle">enableColumnTitle</a></li><li data-type='method'><a href="Sql.html#execute">execute</a></li><li data-type='method'><a href="Sql.html#getBindData">getBindData</a></li><li data-type='method'><a href="Sql.html#getTables">getTables</a></li><li data-type='method'><a href="Sql.html#replaceColumnTableNameWith">replaceColumnTableNameWith</a></li><li data-type='method'><a href="Sql.html#select">select</a></li><li data-type='method'><a href="Sql.html#selectFromSubQuery">selectFromSubQuery</a></li><li data-type='method'><a href="Sql.html#selectJoinSubQuery">selectJoinSubQuery</a></li><li data-type='method'><a href="Sql.html#selectSet">selectSet</a></li><li data-type='method'><a href="Sql.html#setBindValues">setBindValues</a></li><li data-type='method'><a href="Sql.html#setTables">setTables</a></li><li data-type='method'><a href="Sql.html#.cleanUp">cleanUp</a></li><li data-type='method'><a href="Sql.html#.distinctField">distinctField</a></li><li data-type='method'><a href="Sql.html#.errorCheckSelectAST">errorCheckSelectAST</a></li><li data-type='method'><a href="Sql.html#.loadSchema">loadSchema</a></li></ul></li><li><a href="SqlParse.html">SqlParse</a><ul class='methods'><li data-type='method'><a href="SqlParse.html#.analyzeParts">analyzeParts</a></li><li data-type='method'><a href="SqlParse.html#.generateSqlSeparatorWords">generateSqlSeparatorWords</a></li><li data-type='method'><a href="SqlParse.html#.generateUsedKeywordList">generateUsedKeywordList</a></li><li data-type='method'><a href="SqlParse.html#.getPositionsOfSqlParts">getPositionsOfSqlParts</a></li><li data-type='method'><a href="SqlParse.html#.hideInnerSql">hideInnerSql</a></li><li data-type='method'><a href="SqlParse.html#.protect">protect</a></li><li data-type='method'><a href="SqlParse.html#.removeDuplicateEntries">removeDuplicateEntries</a></li><li data-type='method'><a href="SqlParse.html#.reorganizeJoins">reorganizeJoins</a></li><li data-type='method'><a href="SqlParse.html#.reorganizeSpecificJoin">reorganizeSpecificJoin</a></li><li data-type='method'><a href="SqlParse.html#.resolveSqlCondition">resolveSqlCondition</a></li><li data-type='method'><a href="SqlParse.html#.sql2ast">sql2ast</a></li><li data-type='method'><a href="SqlParse.html#.sqlCondition2JsCondition">sqlCondition2JsCondition</a></li><li data-type='method'><a href="SqlParse.html#.unprotect">unprotect</a></li></ul></li><li><a href="SqlServerFunctions.html">SqlServerFunctions</a><ul class='methods'><li data-type='method'><a href="SqlServerFunctions.html#adddate">adddate</a></li><li data-type='method'><a href="SqlServerFunctions.html#case">case</a></li><li data-type='method'><a href="SqlServerFunctions.html#caseEnd">caseEnd</a></li><li data-type='method'><a href="SqlServerFunctions.html#caseStart">caseStart</a></li><li data-type='method'><a href="SqlServerFunctions.html#caseWhen">caseWhen</a></li><li data-type='method'><a href="SqlServerFunctions.html#ceiling">ceiling</a></li><li data-type='method'><a href="SqlServerFunctions.html#charindex">charindex</a></li><li data-type='method'><a href="SqlServerFunctions.html#coalesce">coalesce</a></li><li data-type='method'><a href="SqlServerFunctions.html#concat">concat</a></li><li data-type='method'><a href="SqlServerFunctions.html#concat_ws">concat_ws</a></li><li data-type='method'><a href="SqlServerFunctions.html#convert">convert</a></li><li data-type='method'><a href="SqlServerFunctions.html#convertToJs">convertToJs</a></li><li data-type='method'><a href="SqlServerFunctions.html#curdate">curdate</a></li><li data-type='method'><a href="SqlServerFunctions.html#datediff">datediff</a></li><li data-type='method'><a href="SqlServerFunctions.html#day">day</a></li><li data-type='method'><a href="SqlServerFunctions.html#floor">floor</a></li><li data-type='method'><a href="SqlServerFunctions.html#getReferencedColumns">getReferencedColumns</a></li><li data-type='method'><a href="SqlServerFunctions.html#if">if</a></li><li data-type='method'><a href="SqlServerFunctions.html#left">left</a></li><li data-type='method'><a href="SqlServerFunctions.html#len">len</a></li><li data-type='method'><a href="SqlServerFunctions.html#length">length</a></li><li data-type='method'><a href="SqlServerFunctions.html#log">log</a></li><li data-type='method'><a href="SqlServerFunctions.html#log10">log10</a></li><li data-type='method'><a href="SqlServerFunctions.html#lower">lower</a></li><li data-type='method'><a href="SqlServerFunctions.html#ltrim">ltrim</a></li><li data-type='method'><a href="SqlServerFunctions.html#month">month</a></li><li data-type='method'><a href="SqlServerFunctions.html#now">now</a></li><li data-type='method'><a href="SqlServerFunctions.html#parseFunctionArgs">parseFunctionArgs</a></li><li data-type='method'><a href="SqlServerFunctions.html#power">power</a></li><li data-type='method'><a href="SqlServerFunctions.html#rand">rand</a></li><li data-type='method'><a href="SqlServerFunctions.html#replicate">replicate</a></li><li data-type='method'><a href="SqlServerFunctions.html#reverse">reverse</a></li><li data-type='method'><a href="SqlServerFunctions.html#right">right</a></li><li data-type='method'><a href="SqlServerFunctions.html#round">round</a></li><li data-type='method'><a href="SqlServerFunctions.html#rtrim">rtrim</a></li><li data-type='method'><a href="SqlServerFunctions.html#space">space</a></li><li data-type='method'><a href="SqlServerFunctions.html#sqrt">sqrt</a></li><li data-type='method'><a href="SqlServerFunctions.html#stuff">stuff</a></li><li data-type='method'><a href="SqlServerFunctions.html#substr">substr</a></li><li data-type='method'><a href="SqlServerFunctions.html#substring">substring</a></li><li data-type='method'><a href="SqlServerFunctions.html#trim">trim</a></li><li data-type='method'><a href="SqlServerFunctions.html#upper">upper</a></li><li data-type='method'><a href="SqlServerFunctions.html#year">year</a></li><li data-type='method'><a href="SqlServerFunctions.html#.adddate">adddate</a></li><li data-type='method'><a href="SqlServerFunctions.html#.charIndex">charIndex</a></li><li data-type='method'><a href="SqlServerFunctions.html#.coalesce">coalesce</a></li><li data-type='method'><a href="SqlServerFunctions.html#.concat">concat</a></li><li data-type='method'><a href="SqlServerFunctions.html#.concat_ws">concat_ws</a></li><li data-type='method'><a href="SqlServerFunctions.html#.convert">convert</a></li><li data-type='method'><a href="SqlServerFunctions.html#.datediff">datediff</a></li></ul></li><li><a href="SqlSets.html">SqlSets</a><ul class='methods'><li data-type='method'><a href="SqlSets.html#.applySet">applySet</a></li><li data-type='method'><a href="SqlSets.html#.exceptRows">exceptRows</a></li><li data-type='method'><a href="SqlSets.html#.getSetType">getSetType</a></li><li data-type='method'><a href="SqlSets.html#.getUnionTypes">getUnionTypes</a></li><li data-type='method'><a href="SqlSets.html#.intersectRows">intersectRows</a></li><li data-type='method'><a href="SqlSets.html#.isSqlSet">isSqlSet</a></li><li data-type='method'><a href="SqlSets.html#.removeDuplicateRows">removeDuplicateRows</a></li></ul></li><li><a href="SqlUnionParse.html">SqlUnionParse</a><ul class='methods'><li data-type='method'><a href="SqlUnionParse.html#.makeSqlPartsSplitterRegEx">makeSqlPartsSplitterRegEx</a></li><li data-type='method'><a href="SqlUnionParse.html#.parseUnion">parseUnion</a></li><li data-type='method'><a href="SqlUnionParse.html#.reorganizeUnions">reorganizeUnions</a></li><li data-type='method'><a href="SqlUnionParse.html#.sqlSetStatementSplitter">sqlSetStatementSplitter</a></li></ul></li><li><a href="Table.html">Table</a><ul class='methods'><li data-type='method'><a href="Table.html#addColumnLetters">addColumnLetters</a></li><li data-type='method'><a href="Table.html#concat">concat</a></li><li data-type='method'><a href="Table.html#createCalcFieldRecordMap">createCalcFieldRecordMap</a></li><li data-type='method'><a href="Table.html#createKeyFieldRecordMap">createKeyFieldRecordMap</a></li><li data-type='method'><a href="Table.html#getAllExtendedNotationFieldNames">getAllExtendedNotationFieldNames</a></li><li data-type='method'><a href="Table.html#getAllFieldNames">getAllFieldNames</a></li><li data-type='method'><a href="Table.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="Table.html#getColumnCount">getColumnCount</a></li><li data-type='method'><a href="Table.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="Table.html#getFieldColumns">getFieldColumns</a></li><li data-type='method'><a href="Table.html#getRecords">getRecords</a></li><li data-type='method'><a href="Table.html#loadArrayData">loadArrayData</a></li><li data-type='method'><a href="Table.html#loadNamedRangeData">loadNamedRangeData</a></li><li data-type='method'><a href="Table.html#loadSchema">loadSchema</a></li><li data-type='method'><a href="Table.html#numberToSheetColumnLetter">numberToSheetColumnLetter</a></li><li data-type='method'><a href="Table.html#setHasColumnTitle">setHasColumnTitle</a></li><li data-type='method'><a href="Table.html#setTableAlias">setTableAlias</a></li><li data-type='method'><a href="Table.html#.removeEmptyRecordsAtEndOfTable">removeEmptyRecordsAtEndOfTable</a></li></ul></li><li><a href="TableAlias.html">TableAlias</a><ul class='methods'><li data-type='method'><a href="TableAlias.html#.getTableAlias">getTableAlias</a></li><li data-type='method'><a href="TableAlias.html#.getTableAliasFromJoin">getTableAliasFromJoin</a></li><li data-type='method'><a href="TableAlias.html#.getTableAliasUnion">getTableAliasUnion</a></li><li data-type='method'><a href="TableAlias.html#.getTableAliasWhereIn">getTableAliasWhereIn</a></li><li data-type='method'><a href="TableAlias.html#.getTableAliasWhereTerms">getTableAliasWhereTerms</a></li><li data-type='method'><a href="TableAlias.html#.isIterable">isIterable</a></li><li data-type='method'><a href="TableAlias.html#.locateAstTableAlias">locateAstTableAlias</a></li><li data-type='method'><a href="TableAlias.html#.setTableAlias">setTableAlias</a></li></ul></li><li><a href="TableData.html">TableData</a><ul class='methods'><li data-type='method'><a href="TableData.html#.cacheGetArray">cacheGetArray</a></li><li data-type='method'><a href="TableData.html#.cachePutArray">cachePutArray</a></li><li data-type='method'><a href="TableData.html#.cacheStatusName">cacheStatusName</a></li><li data-type='method'><a href="TableData.html#.fixJSONdates">fixJSONdates</a></li><li data-type='method'><a href="TableData.html#.forceLongCacheExpiryCheck">forceLongCacheExpiryCheck</a></li><li data-type='method'><a href="TableData.html#.getValueCached">getValueCached</a></li><li data-type='method'><a href="TableData.html#.getValuesCached">getValuesCached</a></li><li data-type='method'><a href="TableData.html#.isRangeLoading">isRangeLoading</a></li><li data-type='method'><a href="TableData.html#.isTimeToRunLongCacheExpiry">isTimeToRunLongCacheExpiry</a></li><li data-type='method'><a href="TableData.html#.loadTableData">loadTableData</a></li><li data-type='method'><a href="TableData.html#.loadValuesFromRangeOrSheet">loadValuesFromRangeOrSheet</a></li><li data-type='method'><a href="TableData.html#.lockLoadAndCache">lockLoadAndCache</a></li><li data-type='method'><a href="TableData.html#.setLongCacheExpiry">setLongCacheExpiry</a></li><li data-type='method'><a href="TableData.html#.setValueCached">setValueCached</a></li><li data-type='method'><a href="TableData.html#.setValuesCached">setValuesCached</a></li><li data-type='method'><a href="TableData.html#.verifyCachedData">verifyCachedData</a></li><li data-type='method'><a href="TableData.html#.waitForRangeToLoad">waitForRangeToLoad</a></li></ul></li><li><a href="TableExtract.html">TableExtract</a><ul class='methods'><li data-type='method'><a href="TableExtract.html#.extractAstTables">extractAstTables</a></li><li data-type='method'><a href="TableExtract.html#.getReferencedTableNames">getReferencedTableNames</a></li><li data-type='method'><a href="TableExtract.html#.getReferencedTableNamesFromAst">getReferencedTableNamesFromAst</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesCorrelatedSelect">getTableNamesCorrelatedSelect</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesFrom">getTableNamesFrom</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesJoin">getTableNamesJoin</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesUnion">getTableNamesUnion</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesWhereCondition">getTableNamesWhereCondition</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesWhereIn">getTableNamesWhereIn</a></li><li data-type='method'><a href="TableExtract.html#.getTableNamesWhereTerms">getTableNamesWhereTerms</a></li></ul></li><li><a href="TableField.html">TableField</a><ul class='methods'><li data-type='method'><a href="TableField.html#addAlias">addAlias</a></li><li data-type='method'><a href="TableField.html#getData">getData</a></li><li data-type='method'><a href="TableField.html#setAggregateFunction">setAggregateFunction</a></li><li data-type='method'><a href="TableField.html#setCalculatedFormula">setCalculatedFormula</a></li><li data-type='method'><a href="TableField.html#setColumnName">setColumnName</a></li><li data-type='method'><a href="TableField.html#setColumnTitle">setColumnTitle</a></li><li data-type='method'><a href="TableField.html#setDistinctSetting">setDistinctSetting</a></li><li data-type='method'><a href="TableField.html#setIsPrimaryTable">setIsPrimaryTable</a></li><li data-type='method'><a href="TableField.html#setIsTempField">setIsTempField</a></li><li data-type='method'><a href="TableField.html#setOriginalTable">setOriginalTable</a></li><li data-type='method'><a href="TableField.html#setOriginalTableColumn">setOriginalTableColumn</a></li><li data-type='method'><a href="TableField.html#setSelectColumn">setSelectColumn</a></li><li data-type='method'><a href="TableField.html#setSubQueryAst">setSubQueryAst</a></li><li data-type='method'><a href="TableField.html#setTableInfo">setTableInfo</a></li><li data-type='method'><a href="TableField.html#.getAllExtendedAliasNames">getAllExtendedAliasNames</a></li></ul></li><li><a href="TableFields.html">TableFields</a><ul class='methods'><li data-type='method'><a href="TableFields.html#findTableField">findTableField</a></li><li data-type='method'><a href="TableFields.html#getColumnNames">getColumnNames</a></li><li data-type='method'><a href="TableFields.html#getColumnTitles">getColumnTitles</a></li><li data-type='method'><a href="TableFields.html#getConglomerateFieldCount">getConglomerateFieldCount</a></li><li data-type='method'><a href="TableFields.html#getFieldColumn">getFieldColumn</a></li><li data-type='method'><a href="TableFields.html#getFieldInfo">getFieldInfo</a></li><li data-type='method'><a href="TableFields.html#getNextSelectColumnNumber">getNextSelectColumnNumber</a></li><li data-type='method'><a href="TableFields.html#getSelectFieldColumn">getSelectFieldColumn</a></li><li data-type='method'><a href="TableFields.html#getSelectFields">getSelectFields</a></li><li data-type='method'><a href="TableFields.html#getTableInfo">getTableInfo</a></li><li data-type='method'><a href="TableFields.html#getTempSelectedColumnNumbers">getTempSelectedColumnNumbers</a></li><li data-type='method'><a href="TableFields.html#hasField">hasField</a></li><li data-type='method'><a href="TableFields.html#indexTableField">indexTableField</a></li><li data-type='method'><a href="TableFields.html#loadVirtualFields">loadVirtualFields</a></li><li data-type='method'><a href="TableFields.html#parseAstSelectField">parseAstSelectField</a></li><li data-type='method'><a href="TableFields.html#updateCalculatedAsSelected">updateCalculatedAsSelected</a></li><li data-type='method'><a href="TableFields.html#updateColumnAsSelected">updateColumnAsSelected</a></li><li data-type='method'><a href="TableFields.html#updateConstantAsSelected">updateConstantAsSelected</a></li><li data-type='method'><a href="TableFields.html#updateDerivedTableVirtualFields">updateDerivedTableVirtualFields</a></li><li data-type='method'><a href="TableFields.html#updateSelectFieldList">updateSelectFieldList</a></li><li data-type='method'><a href="TableFields.html#.getSelectCountModifiers">getSelectCountModifiers</a></li><li data-type='method'><a href="TableFields.html#.sortPrimaryFields">sortPrimaryFields</a></li></ul></li><li><a href="TestedStatements.html">TestedStatements</a><ul class='methods'><li data-type='method'><a href="TestedStatements.html#getTableDefinitionString">getTableDefinitionString</a></li></ul></li><li><a href="VirtualField.html">VirtualField</a></li><li><a href="VirtualFields.html">VirtualFields</a><ul class='methods'><li data-type='method'><a href="VirtualFields.html#add">add</a></li><li data-type='method'><a href="VirtualFields.html#getAllVirtualFields">getAllVirtualFields</a></li><li data-type='method'><a href="VirtualFields.html#.expandWildcardFields">expandWildcardFields</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#SQLselfTest">SQLselfTest</a></li><li><a href="global.html#customMenuGenerateTests">customMenuGenerateTests</a></li><li><a href="global.html#gsSQL">gsSQL</a></li><li><a href="global.html#isEqual">isEqual</a></li><li><a href="global.html#onOpen">onOpen</a></li><li><a href="global.html#sqlTestCases">sqlTestCases</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">SimpleParser.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//  *** DEBUG START ***
//  Remove comments for testing in NODE
export { SqlParse };
//  *** DEBUG END ***/

//  Code inspired from:  https://github.com/dsferruzza/simpleSqlParser

/**
 * @classdesc 
 * Parse SQL SELECT statement and convert into Abstract Syntax Tree 
 */
class SqlParse {
    /**
     * @param {String} cond 
     * @returns {String}
     */
    static sqlCondition2JsCondition(cond) {
        const ast = SqlParse.sql2ast(`SELECT A FROM c WHERE ${cond}`);
        let sqlData = "";

        if (typeof ast.WHERE !== 'undefined') {
            const conditions = ast.WHERE;
            if (typeof conditions.logic === 'undefined') {
                sqlData = SqlParse.resolveSqlCondition("OR", [conditions]);
            }
            else {
                sqlData = SqlParse.resolveSqlCondition(conditions.logic, conditions.terms);
            }

        }

        return sqlData;
    }

    /**
     * Parse a query
     * @param {String} query 
     * @returns {Object}
     */
    static sql2ast(query) {
        // Define which words can act as separator
        const myKeyWords = SqlParse.generateUsedKeywordList(query);
        const [parts_name, parts_name_escaped] = SqlParse.generateSqlSeparatorWords(myKeyWords);

        // Hide words defined as separator but written inside brackets in the query
        const hiddenQuery = SqlParse.hideInnerSql(query, parts_name_escaped, SqlParse.protect);

        //  Include brackets around separate selects used in things like UNION, INTERSECT...
        let modifiedQuery = SqlUnionParse.sqlSetStatementSplitter(hiddenQuery);

        //  The SET statement splitter creates a bracketed sub-query, which we need to hide.
        if (modifiedQuery !== hiddenQuery) {
            modifiedQuery = SqlParse.hideInnerSql(modifiedQuery, parts_name_escaped, SqlParse.protect);
        }

        // Write the position(s) in query of these separators
        const parts_order = SqlParse.getPositionsOfSqlParts(modifiedQuery, parts_name);

        // Delete duplicates (caused, for example, by JOIN and INNER JOIN)
        SqlParse.removeDuplicateEntries(parts_order);

        // Generate protected word list to reverse the use of protect()
        let words = parts_name_escaped.slice(0);
        words = words.map(item => SqlParse.protect(item));

        // Split parts
        const parts = modifiedQuery.split(new RegExp(parts_name_escaped.join('|'), 'i'));

        // Unhide words previously hidden with protect()
        for (let i = 0; i &lt; parts.length; i++) {
            parts[i] = SqlParse.hideInnerSql(parts[i], words, SqlParse.unprotect);
        }

        // Analyze parts
        const result = SqlParse.analyzeParts(parts_order, parts);

        if (typeof result.FROM !== 'undefined' &amp;&amp; typeof result.FROM.FROM !== 'undefined' &amp;&amp; typeof result.FROM.FROM.as !== 'undefined') {
            if (result.FROM.FROM.as === '') {
                throw new Error("Every derived table must have its own alias");
            }

            //   Subquery FROM creates an ALIAS name, which is then used as FROM table name.
            result.FROM.table = result.FROM.FROM.as;
            result.FROM.isDerived = true;
        }

        return result;
    }

    /**
    * 
    * @param {String} logic 
    * @param {Object} terms 
    * @returns {String}
    */
    static resolveSqlCondition(logic, terms) {
        let jsCondition = "";

        for (const cond of terms) {
            if (typeof cond.logic === 'undefined') {
                if (jsCondition !== "" &amp;&amp; logic === "AND") {
                    jsCondition += " &amp;&amp; ";
                }
                else if (jsCondition !== "" &amp;&amp; logic === "OR") {
                    jsCondition += " || ";
                }

                jsCondition += ` ${cond.left}`;
                if (cond.operator === "=") {
                    jsCondition += " == ";
                }
                else {
                    jsCondition += ` ${cond.operator}`;
                }
                jsCondition += ` ${cond.right}`;
            }
            else {
                jsCondition += SqlParse.resolveSqlCondition(cond.logic, cond.terms);
            }
        }

        return jsCondition;
    }

    /**
     * Returns a list of all keywords used in their original CASE.
     * @param {String} query
     * @returns {String[]} 
     */
    static generateUsedKeywordList(query) {
        const generatedList = new Set();
        // Define which words can act as separator
        const keywords = ['SELECT', 'FROM', 'JOIN', 'LEFT JOIN', 'RIGHT JOIN', 'INNER JOIN', 'FULL JOIN', 'ORDER BY', 'GROUP BY', 'HAVING', 'WHERE', 'LIMIT', 'UNION ALL', 'UNION', 'INTERSECT', 'EXCEPT', 'PIVOT'];
        const modifiedQuery = query.toUpperCase();

        for (const word of keywords) {
            let pos = modifiedQuery.indexOf(word, 0);
            while (pos !== -1) {
                generatedList.add(query.substring(pos, pos + word.length));
                pos++;
                pos = modifiedQuery.indexOf(word, pos);
            }
        }

        // @ts-ignore
        return [...generatedList];
    }

    /**
     * 
     * @param {String[]} keywords 
     * @returns {String[][]}
     */
    static generateSqlSeparatorWords(keywords) {
        let parts_name = keywords.map(item => `${item} `);
        parts_name = parts_name.concat(keywords.map(item => `${item}(`));
        const parts_name_escaped = parts_name.map(item => item.replace('(', '[\\(]'));

        return [parts_name, parts_name_escaped];
    }

    /**
     * 
     * @param {String} str 
     * @param {String[]} parts_name_escaped
     * @param {Object} replaceFunction
     */
    static hideInnerSql(str, parts_name_escaped, replaceFunction) {
        if (str.indexOf("(") === -1 &amp;&amp; str.indexOf(")") === -1)
            return str;

        let bracketCount = 0;
        let endCount = -1;
        let newStr = str;

        for (let i = newStr.length - 1; i >= 0; i--) {
            const ch = newStr.charAt(i);

            if (ch === ")") {
                bracketCount++;

                if (bracketCount === 1) {
                    endCount = i;
                }
            }
            else if (ch === "(") {
                bracketCount--;
                if (bracketCount === 0) {

                    let query = newStr.substring(i, endCount + 1);

                    // Hide words defined as separator but written inside brackets in the query
                    query = query.replace(new RegExp(parts_name_escaped.join('|'), 'gi'), replaceFunction);

                    newStr = newStr.substring(0, i) + query + newStr.substring(endCount + 1);
                }
            }
        }
        return newStr;
    }

    /**
     * 
     * @param {String} modifiedQuery 
     * @param {String[]} parts_name 
     * @returns {String[]}
     */
    static getPositionsOfSqlParts(modifiedQuery, parts_name) {
        // Write the position(s) in query of these separators
        const parts_order = [];

        /**
         * 
         * @param {String} _match 
         * @param {String} name 
         * @returns {String}
         */
        function realNameCallback(_match, name) {
            return name;
        }

        parts_name.forEach(item => {
            let pos = 0;
            let part = 0;

            do {
                part = modifiedQuery.indexOf(item, pos);
                if (part !== -1) {
                    const realName = item.replace(/^((\w|\s)+?)\s?\(?$/i, realNameCallback);

                    if (typeof parts_order[part] === 'undefined' || parts_order[part].length &lt; realName.length) {
                        parts_order[part] = realName;	// Position won't be exact because the use of protect()  (above) and unprotect() alter the query string ; but we just need the order :)
                    }

                    pos = part + realName.length;
                }
            }
            while (part !== -1);
        });

        return parts_order;
    }

    /**
     * Delete duplicates (caused, for example, by JOIN and INNER JOIN)
     * @param {String[]} parts_order
     */
    static removeDuplicateEntries(parts_order) {
        let busy_until = 0;
        parts_order.forEach((item, key) => {
            if (busy_until > key) {
                delete parts_order[key];
            }
            else {
                busy_until = key + item.length;

                // Replace JOIN by INNER JOIN
                if (item.toUpperCase() === 'JOIN')
                    parts_order[key] = 'INNER JOIN';
            }
        });
    }

    /**
     * Add some # inside a string to avoid it to match a regex/split
     * @param {String} str 
     * @returns {String}
     */
    static protect(str) {
        let result = '#';
        const length = str.length;
        for (let i = 0; i &lt; length; i++) {
            result += `${str[i]}#`;
        }
        return result;
    }

    /**
     * Restore a string output by protect() to its original state
     * @param {String} str 
     * @returns {String}
     */
    static unprotect(str) {
        let result = '';
        const length = str.length;
        for (let i = 1; i &lt; length; i = i + 2) result += str[i];
        return result;
    }

    /**
     * 
     * @param {String[]} parts_order 
     * @param {String[]} parts 
     * @returns {Object}
     */
    static analyzeParts(parts_order, parts) {
        const result = {};
        let j = 0;
        parts_order.forEach(item => {
            const itemName = item.toUpperCase();
            j++;
            const selectComponentAst = SelectKeywordAnalysis.analyze(item, parts[j]);

            if (typeof result[itemName] !== 'undefined') {
                if (typeof result[itemName] === 'string' || typeof result[itemName][0] === 'undefined') {
                    const tmp = result[itemName];
                    result[itemName] = [];
                    result[itemName].push(tmp);
                }

                result[itemName].push(selectComponentAst);
            }
            else {
                result[itemName] = selectComponentAst;
            }

        });

        // Reorganize joins
        SqlParse.reorganizeJoins(result);

        if (typeof result.JOIN !== 'undefined') {
            result.JOIN.forEach((item, key) => { result.JOIN[key].cond = CondParser.parse(item.cond) });
        }

        SqlUnionParse.reorganizeUnions(result);

        return result;
    }

    /**
     * 
     * @param {Object} result 
     */
    static reorganizeJoins(result) {
        const joinArr = [
            ['FULL JOIN', 'full'],
            ['RIGHT JOIN', 'right'],
            ['INNER JOIN', 'inner'],
            ['LEFT JOIN', 'left']
        ];

        for (const join of joinArr) {
            const [joinName, joinType] = join;
            SqlParse.reorganizeSpecificJoin(result, joinName, joinType);
        }
    }

    /**
     * 
     * @param {Object} result 
     * @param {String} joinName 
     * @param {String} joinType 
     */
    static reorganizeSpecificJoin(result, joinName, joinType) {
        if (typeof result[joinName] !== 'undefined') {
            if (typeof result.JOIN === 'undefined') result.JOIN = [];
            if (typeof result[joinName][0] !== 'undefined') {
                result[joinName].forEach(item => {
                    item.type = joinType;
                    result.JOIN.push(item);
                });
            }
            else {
                result[joinName].type = joinType;
                result.JOIN.push(result[joinName]);
            }
            delete result[joinName];
        }
    }
}

/**
 * @classdesc Parsing SQL set commands into AST.
 */
class SqlUnionParse {
    /**
     * 
     * @param {String} src 
     * @returns {String}
     */
    static sqlSetStatementSplitter(src) {
        let newStr = src;

        // Define which words can act as separator
        const reg = SqlUnionParse.makeSqlPartsSplitterRegEx(["UNION ALL", "UNION", "INTERSECT", "EXCEPT"]);

        const matchedUnions = reg.exec(newStr);
        if (matchedUnions === null || matchedUnions.length === 0) {
            return newStr;
        }

        let prefix = "";
        const parts = [];
        let pos = newStr.search(matchedUnions[0]);
        if (pos > 0) {
            prefix = newStr.substring(0, pos);
            newStr = newStr.substring(pos + matchedUnions[0].length);
        }

        for (let i = 1; i &lt; matchedUnions.length; i++) {
            const match = matchedUnions[i];
            pos = newStr.search(match);

            parts.push(newStr.substring(0, pos));
            newStr = newStr.substring(pos + match.length);
        }
        if (newStr.length > 0)
            parts.push(newStr);

        newStr = prefix;
        for (let i = 0; i &lt; matchedUnions.length; i++) {
            newStr += `${matchedUnions[i]} (${parts[i]}) `;
        }

        return newStr;
    }

    /**
     * 
     * @param {String[]} keywords 
     * @returns {RegExp}
     */
    static makeSqlPartsSplitterRegEx(keywords) {
        // Define which words can act as separator
        let parts_name = keywords.map(item => `${item} `);
        parts_name = parts_name.concat(keywords.map(item => `${item}(`));
        parts_name = parts_name.concat(parts_name.map(item => item.toLowerCase()));
        const parts_name_escaped = parts_name.map(item => item.replace('(', '[\\(]'));

        return new RegExp(parts_name_escaped.join('|'), 'gi');
    }

    /**
     * 
     * @param {Object} result 
     */
    static reorganizeUnions(result) {
        const astRecursiveTableBlocks = ['UNION', 'UNION ALL', 'INTERSECT', 'EXCEPT'];

        for (const union of astRecursiveTableBlocks) {
            if (typeof result[union] === 'string') {
                result[union] = [SqlParse.sql2ast(SqlUnionParse.parseUnion(result[union]))];
            }
            else if (typeof result[union] !== 'undefined') {
                for (let i = 0; i &lt; result[union].length; i++) {
                    result[union][i] = SqlParse.sql2ast(SqlUnionParse.parseUnion(result[union][i]));
                }
            }
        }
    }

    /**
     * 
     * @param {String} inStr 
     * @returns {String}
     */
    static parseUnion(inStr) {
        let unionString = inStr;
        if (unionString.startsWith("(") &amp;&amp; unionString.endsWith(")")) {
            unionString = unionString.substring(1, unionString.length - 1);
        }

        return unionString;
    }
}

/*
 * LEXER &amp; PARSER FOR SQL CONDITIONS
 * Inspired by https://github.com/DmitrySoshnikov/Essentials-of-interpretation
 */

/** Lexical analyzer for SELECT statement. */
class CondLexer {
    constructor(source) {
        this.source = source;
        this.cursor = 0;
        this.currentChar = "";
        this.startQuote = "";
        this.bracketCount = 0;

        this.readNextChar();
    }

    // Read the next character (or return an empty string if cursor is at the end of the source)
    readNextChar() {
        if (typeof this.source !== 'string') {
            this.currentChar = "";
        }
        else {
            this.currentChar = this.source[this.cursor++] ?? "";
        }
    }

    /**
     * Determine the next token
     * @returns {Object}
     */
    readNextToken() {
        if (/\w/.test(this.currentChar))
            return this.readWord();
        if (/["'`]/.test(this.currentChar))
            return this.readString();
        if (/[()]/.test(this.currentChar))
            return this.readGroupSymbol();
        if (/[!=&lt;>]/.test(this.currentChar))
            return this.readOperator();
        if (/[+\-*/%]/.test(this.currentChar))
            return this.readMathOperator();
        if (this.currentChar === '?')
            return this.readBindVariable();

        if (this.currentChar === "") {
            return { type: 'eot', value: '' };
        }

        this.readNextChar();
        return { type: 'empty', value: '' };
    }

    /**
     * 
     * @returns {Object}
     */
    readWord() {
        let tokenValue = "";
        this.bracketCount = 0;
        let insideQuotedString = false;
        this.startQuote = "";

        while (/./.test(this.currentChar)) {
            // Check if we are in a string
            insideQuotedString = this.isStartOrEndOfString(insideQuotedString);

            if (this.isFinishedWord(insideQuotedString))
                break;

            tokenValue += this.currentChar;
            this.readNextChar();
        }

        if (/^(AND|OR)$/i.test(tokenValue)) {
            return { type: 'logic', value: tokenValue.toUpperCase() };
        }

        if (/^(IN|IS|NOT|LIKE|NOT EXISTS|EXISTS)$/i.test(tokenValue)) {
            return { type: 'operator', value: tokenValue.toUpperCase() };
        }

        return { type: 'word', value: tokenValue };
    }

    /**
     * 
     * @param {Boolean} insideQuotedString 
     * @returns {Boolean}
     */
    isStartOrEndOfString(insideQuotedString) {
        if (!insideQuotedString &amp;&amp; /['"`]/.test(this.currentChar)) {
            this.startQuote = this.currentChar;

            return true;
        }
        else if (insideQuotedString &amp;&amp; this.currentChar === this.startQuote) {
            //  End of quoted string.
            return false;
        }

        return insideQuotedString;
    }

    /**
     * 
     * @param {Boolean} insideQuotedString 
     * @returns {Boolean}
     */
    isFinishedWord(insideQuotedString) {
        if (insideQuotedString)
            return false;

        // Token is finished if there is a closing bracket outside a string and with no opening
        if (this.currentChar === ')' &amp;&amp; this.bracketCount &lt;= 0) {
            return true;
        }

        if (this.currentChar === '(') {
            this.bracketCount++;
        }
        else if (this.currentChar === ')') {
            this.bracketCount--;
        }

        // Token is finished if there is a operator symbol outside a string
        if (/[!=&lt;>]/.test(this.currentChar)) {
            return true;
        }

        // Token is finished on the first space which is outside a string or a function
        return this.currentChar === ' ' &amp;&amp; this.bracketCount &lt;= 0;
    }

    /**
     * 
     * @returns {Object}
     */
    readString() {
        let tokenValue = "";
        const quote = this.currentChar;

        tokenValue += this.currentChar;
        this.readNextChar();

        while (this.currentChar !== quote &amp;&amp; this.currentChar !== "") {
            tokenValue += this.currentChar;
            this.readNextChar();
        }

        tokenValue += this.currentChar;
        this.readNextChar();

        // Handle this case : `table`.`column`
        if (this.currentChar === '.') {
            tokenValue += this.currentChar;
            this.readNextChar();
            tokenValue += this.readString().value;

            return { type: 'word', value: tokenValue };
        }

        return { type: 'string', value: tokenValue };
    }

    /**
     * 
     * @returns {Object}
     */
    readGroupSymbol() {
        const tokenValue = this.currentChar;
        this.readNextChar();

        return { type: 'group', value: tokenValue };
    }

    /**
     * 
     * @returns {Object}
     */
    readOperator() {
        let tokenValue = this.currentChar;
        this.readNextChar();

        if (/[=&lt;>]/.test(this.currentChar)) {
            tokenValue += this.currentChar;
            this.readNextChar();
        }

        return { type: 'operator', value: tokenValue };
    }

    /**
     * 
     * @returns {Object}
     */
    readMathOperator() {
        const tokenValue = this.currentChar;
        this.readNextChar();

        return { type: 'mathoperator', value: tokenValue };
    }

    /**
     * 
     * @returns {Object}
     */
    readBindVariable() {
        let tokenValue = this.currentChar;
        this.readNextChar();

        while (/\d/.test(this.currentChar)) {
            tokenValue += this.currentChar;
            this.readNextChar();
        }

        return { type: 'bindVariable', value: tokenValue };
    }
}

/** SQL Condition parser class. */
class CondParser {
    constructor(source) {
        this.lexer = new CondLexer(source);
        this.currentToken = {};

        this.readNextToken();
    }

    /**
     * Parse a string
     * @param {String} source 
     * @returns {Object}
     */
    static parse(source) {
        return new CondParser(source).parseExpressionsRecursively();
    }

    /**
     * Read the next token (skip empty tokens)
     * @returns {Object}
     */
    readNextToken() {
        this.currentToken = this.lexer.readNextToken();
        while (this.currentToken.type === 'empty')
            this.currentToken = this.lexer.readNextToken();
        return this.currentToken;
    }

    /**
     * Wrapper function ; parse the source
     * @returns {Object}
     */
    parseExpressionsRecursively() {
        return this.parseLogicalExpression();
    }

    /**
     * Parse logical expressions (AND/OR)
     * @returns {Object}
     */
    parseLogicalExpression() {
        let leftNode = this.parseConditionExpression();

        while (this.currentToken.type === 'logic') {
            const logic = this.currentToken.value;
            this.readNextToken();

            const rightNode = this.parseConditionExpression();

            // If we are chaining the same logical operator, add nodes to existing object instead of creating another one
            if (typeof leftNode.logic !== 'undefined' &amp;&amp; leftNode.logic === logic &amp;&amp; typeof leftNode.terms !== 'undefined')
                leftNode.terms.push(rightNode);
            else {
                const terms = [leftNode, rightNode].slice(0);
                leftNode = { logic, terms };
            }
        }

        return leftNode;
    }

    /**
     * Parse conditions ([word/string] [operator] [word/string])
     * @returns {Object}
     */
    parseConditionExpression() {
        let left = this.parseBaseExpression();

        if (this.currentToken.type !== 'operator') {
            return left;
        }

        let operator = this.currentToken.value;
        this.readNextToken();

        // If there are 2 adjacent operators, join them with a space (exemple: IS NOT)
        if (this.currentToken.type === 'operator') {
            operator += ` ${this.currentToken.value}`;
            this.readNextToken();
        }

        let right = null;
        if (this.currentToken.type === 'group' &amp;&amp; (operator === 'EXISTS' || operator === 'NOT EXISTS')) {
            [left, right] = this.parseSelectExistsSubQuery();
        } else {
            right = this.parseBaseExpression(operator);
        }

        return { operator, left, right };
    }

    /**
     * 
     * @returns {Object[]}
     */
    parseSelectExistsSubQuery() {
        let rightNode = null;
        const leftNode = '""';

        this.readNextToken();
        if (this.currentToken.type === 'word' &amp;&amp; this.currentToken.value === 'SELECT') {
            rightNode = this.parseSelectIn("", true);
            if (this.currentToken.type === 'group') {
                this.readNextToken();
            }
        }

        return [leftNode, rightNode];
    }

    // Parse base items
    /**
     * 
     * @param {String} operator 
     * @returns {Object}
     */
    parseBaseExpression(operator = "") {
        let astNode = {};

        // If this is a word/string, return its value
        if (this.currentToken.type === 'word' || this.currentToken.type === 'string') {
            astNode = this.parseWordExpression();
        }
        // If this is a group, skip brackets and parse the inside
        else if (this.currentToken.type === 'group') {
            astNode = this.parseGroupExpression(operator);
        }
        else if (this.currentToken.type === 'bindVariable') {
            astNode = this.currentToken.value;
            this.readNextToken();
        }

        return astNode;
    }

    /**
     * 
     * @returns {Object}
     */
    parseWordExpression() {
        let astNode = this.currentToken.value;
        this.readNextToken();

        if (this.currentToken.type === 'mathoperator') {
            astNode += ` ${this.currentToken.value}`;
            this.readNextToken();
            while ((this.currentToken.type === 'mathoperator' || this.currentToken.type === 'word') &amp;&amp; this.currentToken.type !== 'eot') {
                astNode += ` ${this.currentToken.value}`;
                this.readNextToken();
            }
        }

        return astNode;
    }

    /**
     * 
     * @param {String} operator 
     * @returns {Object}
     */
    parseGroupExpression(operator) {
        this.readNextToken();
        let astNode = this.parseExpressionsRecursively();

        const isSelectStatement = typeof astNode === "string" &amp;&amp; astNode.toUpperCase() === 'SELECT';

        if (operator === 'IN' || operator === 'NOT IN' || isSelectStatement) {
            astNode = this.parseSelectIn(astNode, isSelectStatement);
        }

        this.readNextToken();

        return astNode;
    }

    /**
     * 
     * @param {any} startAstNode 
     * @param {Boolean} isSelectStatement 
     * @returns {Object}
     */
    parseSelectIn(startAstNode, isSelectStatement) {
        let astNode = startAstNode;
        let inCurrentToken = this.currentToken;
        let bracketCount = 1;

        //  If only one item in list, we hit the end bracket immediately.
        bracketCount += CondParser.groupBracketIncrementer(inCurrentToken);

        while (bracketCount !== 0 &amp;&amp; inCurrentToken.type !== 'eot') {
            this.readNextToken();
            if (isSelectStatement) {
                astNode += ` ${inCurrentToken.value}`;
            }
            else {
                astNode += `, ${inCurrentToken.value}`;
            }

            inCurrentToken = this.currentToken;
            bracketCount += CondParser.groupBracketIncrementer(inCurrentToken);
        }

        if (isSelectStatement) {
            astNode = SqlParse.sql2ast(astNode);
        }

        return astNode;
    }

    /**
     * 
     * @param {Object} inCurrentToken 
     * @returns {Number}
     */
    static groupBracketIncrementer(inCurrentToken) {
        let diff = 0;
        if (inCurrentToken.type === 'group') {
            if (inCurrentToken.value === '(') {
                diff = 1;
            }
            else if (inCurrentToken.value === ')') {
                diff = -1;
            }
        }

        return diff
    }
}

/** Analyze each distinct component of SELECT statement. */
class SelectKeywordAnalysis {
    /**
     * 
     * @param {String} itemName 
     * @param {Object} part 
     * @returns {any}
     */
    static analyze(itemName, part) {
        const keyWord = itemName.toUpperCase().replace(/ /g, '_');

        if (typeof SelectKeywordAnalysis[keyWord] === 'undefined') {
            throw new Error(`Can't analyze statement ${itemName}`);
        }

        return SelectKeywordAnalysis[keyWord](part);
    }

    /**
     * 
     * @param {String} str 
     * @param {Boolean} isOrderBy 
     * @returns {Object[]}
     */
    static SELECT(str, isOrderBy = false) {
        const selectParts = SelectKeywordAnalysis.protect_split(',', str);
        const selectResult = selectParts.filter(item => item !== '')
            .map(item => SelectKeywordAnalysis.extractSelectField(item, isOrderBy));

        if (selectResult.length === 0) {
            throw new Error("No fields SELECTED.");
        }

        return selectResult;
    }

    /**
     * 
     * @param {String} item 
     * @param {Boolean} isOrderBy 
     * @returns {Object}
     */
    static extractSelectField(item, isOrderBy) {
        let order = "";
        if (isOrderBy) {
            const order_by = /^(.+?)(\s+ASC|DESC)?$/gi;
            const orderData = order_by.exec(item);
            if (orderData !== null) {
                order = typeof orderData[2] === 'undefined' ? "ASC" : SelectKeywordAnalysis.trim(orderData[2]);
                item = orderData[1].trim();
            }
        }

        //  Is there a column alias?
        const [name, as] = SelectKeywordAnalysis.getNameAndAlias(item);

        const splitPattern = /[\s()*/%+-]+/g;
        let terms = name.split(splitPattern);

        if (terms !== null) {
            const aggFunc = ["SUM", "MIN", "MAX", "COUNT", "AVG", "DISTINCT", "GROUP_CONCAT"];
            terms = (aggFunc.indexOf(terms[0].toUpperCase()) === -1) ? terms : null;
        }
        if (name !== "*" &amp;&amp; terms !== null &amp;&amp; terms.length > 1) {
            const subQuery = SelectKeywordAnalysis.parseForCorrelatedSubQuery(item);
            return { name, terms, as, subQuery, order };
        }

        return { name, as, order };
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static FROM(str) {
        const subqueryAst = this.parseForCorrelatedSubQuery(str);
        if (subqueryAst !== null) {
            //  If there is a subquery creating a DERIVED table, it must have a derived table name.
            //  Extract this subquery AS tableName.
            const [, alias] = SelectKeywordAnalysis.getNameAndAlias(str);
            if (alias !== "" &amp;&amp; typeof subqueryAst.FROM !== 'undefined') {
                subqueryAst.FROM.as = alias.toUpperCase();
            }

            return subqueryAst;
        }

        let fromParts = str.split(',');
        fromParts = fromParts.map(item => SelectKeywordAnalysis.trim(item));

        const fromResult = fromParts.map(item => {
            const [table, as] = SelectKeywordAnalysis.getNameAndAlias(item);
            return { table, as };
        });

        return fromResult[0];
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static LEFT_JOIN(str) {
        return SelectKeywordAnalysis.allJoins(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static INNER_JOIN(str) {
        return SelectKeywordAnalysis.allJoins(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static RIGHT_JOIN(str) {
        return SelectKeywordAnalysis.allJoins(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static FULL_JOIN(str) {
        return SelectKeywordAnalysis.allJoins(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static allJoins(str) {
        const subqueryAst = this.parseForCorrelatedSubQuery(str);

        const strParts = str.toUpperCase().split(' ON ');
        const table = strParts[0].split(' AS ');
        const joinResult = {};
        joinResult.table = subqueryAst !== null ? subqueryAst : SelectKeywordAnalysis.trim(table[0]);
        joinResult.as = SelectKeywordAnalysis.trim(table[1]) ?? '';
        joinResult.cond = SelectKeywordAnalysis.trim(strParts[1]);

        return joinResult;
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static WHERE(str) {
        return CondParser.parse(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object[]}
     */
    static ORDER_BY(str) {
        return SelectKeywordAnalysis.SELECT(str, true);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object[]}
     */
    static GROUP_BY(str) {
        return SelectKeywordAnalysis.SELECT(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object[]}
     */
    static PIVOT(str) {
        const strParts = str.split(',');
        const pivotResult = [];

        strParts.forEach((item) => {
            const pivotOn = /([\w.]+)/gi;
            const pivotData = pivotOn.exec(item);
            if (pivotData !== null) {
                const tmp = {};
                tmp.name = SelectKeywordAnalysis.trim(pivotData[1]);
                tmp.as = "";
                pivotResult.push(tmp);
            }
        });

        return pivotResult;
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static LIMIT(str) {
        const limitResult = {};
        limitResult.nb = Number(str);
        limitResult.from = 0;
        return limitResult;
    }

    /**
     * 
     * @param {String} str 
     * @returns {Object}
     */
    static HAVING(str) {
        return CondParser.parse(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {String}
     */
    static UNION(str) {
        return SelectKeywordAnalysis.trim(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {String}
     */
    static UNION_ALL(str) {
        return SelectKeywordAnalysis.trim(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {String}
     */
    static INTERSECT(str) {
        return SelectKeywordAnalysis.trim(str);
    }

    /**
     * 
     * @param {String} str 
     * @returns {String}
     */
    static EXCEPT(str) {
        return SelectKeywordAnalysis.trim(str);
    }

    /**
     * 
     * @param {String} selectField 
     * @returns {Object}
     */
    static parseForCorrelatedSubQuery(selectField) {
        let subQueryAst = null;

        const regExp = /\(\s*(SELECT[\s\S]+)\)/i;
        const matches = regExp.exec(selectField);

        if (matches !== null &amp;&amp; matches.length > 1) {
            subQueryAst = SqlParse.sql2ast(matches[1]);
        }

        return subQueryAst;
    }

    // Split a string using a separator, only if this separator isn't beetween brackets
    /**
     * 
     * @param {String} separator 
     * @param {String} str 
     * @returns {String[]}
     */
    static protect_split(separator, str) {
        const sep = '######';

        let inQuotedString = false;
        let quoteChar = "";
        let bracketCount = 0;
        let newStr = "";
        for (const c of str) {
            if (!inQuotedString &amp;&amp; /['"`]/.test(c)) {
                inQuotedString = true;
                quoteChar = c;
            }
            else if (inQuotedString &amp;&amp; c === quoteChar) {
                inQuotedString = false;
            }
            else if (!inQuotedString &amp;&amp; c === '(') {
                bracketCount++;
            }
            else if (!inQuotedString &amp;&amp; c === ')') {
                bracketCount--;
            }

            if (c === separator &amp;&amp; (bracketCount > 0 || inQuotedString)) {
                newStr += sep;
            }
            else {
                newStr += c;
            }
        }

        let strParts = newStr.split(separator);
        strParts = strParts.map(item => SelectKeywordAnalysis.trim(item.replace(new RegExp(sep, 'g'), separator)));

        return strParts;
    }

    /**
     * 
     * @param {any} str 
     * @returns {any}
     */
    static trim(str) {
        if (typeof str === 'string')
            return str.trim();
        return str;
    }

    /**
    * If an ALIAS is specified after 'AS', return the field/table name and the alias.
    * @param {String} item 
    * @returns {String[]}
    */
    static getNameAndAlias(item) {
        let realName = item;
        let alias = "";
        const lastAs = SelectKeywordAnalysis.lastIndexOfOutsideLiteral(item.toUpperCase(), " AS ");
        if (lastAs !== -1) {
            const subStr = item.substring(lastAs + 4).trim();
            if (subStr.length > 0) {
                alias = subStr;
                //  Remove quotes, if any.
                if ((subStr.startsWith("'") &amp;&amp; subStr.endsWith("'")) ||
                    (subStr.startsWith('"') &amp;&amp; subStr.endsWith('"')) ||
                    (subStr.startsWith('[') &amp;&amp; subStr.endsWith(']')))
                    alias = subStr.substring(1, subStr.length - 1);

                //  Remove everything after 'AS'.
                realName = item.substring(0, lastAs).trim();
            }
        }

        return [realName, alias];
    }

    /**
     * 
     * @param {String} srcString 
     * @param {String} searchString 
     * @returns {Number}
     */
    static lastIndexOfOutsideLiteral(srcString, searchString) {
        let index = -1;
        let inQuote = "";

        for (let i = 0; i &lt; srcString.length; i++) {
            const ch = srcString.charAt(i);

            if (inQuote !== "") {
                //  The ending quote.
                if ((inQuote === "'" &amp;&amp; ch === "'") || (inQuote === '"' &amp;&amp; ch === '"') || (inQuote === "[" &amp;&amp; ch === "]"))
                    inQuote = "";
            }
            else if ("\"'[".indexOf(ch) !== -1) {
                //  The starting quote.
                inQuote = ch;
            }
            else if (srcString.substring(i).startsWith(searchString)) {
                //  Matched search.
                index = i;
            }
        }

        return index;
    }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Thu Feb 15 2024 20:13:57 GMT-0500 (Eastern Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
